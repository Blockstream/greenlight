# Generated by the gRPC Python protocol compiler plugin. DO NOT EDIT!
"""Client and server classes corresponding to protobuf-defined services."""
import grpc

from . import greenlight_pb2 as greenlight__pb2


class NodeStub(object):
    """The node service represents your node running on greenlight's
    infrastructure. You can use the exposed RPC methods to interact
    with your node. The URI used to connect to the node depends on
    where the node is being scheduled and is returned by the
    `Scheduler.Schedule()` RPC call.

    Notice that in order to connect to the node the caller must use the
    node-specific mTLS keypair returned by `Scheduler.Register()` or
    `Scheduler.Recover()`. In particular the anonymous mTLS keypair is
    rejected by the node.

    Deprecated methods are being replaced by the standardized and
    automatically managed cln-grpc protocol you can find in
    `node.proto`
    """

    def __init__(self, channel):
        """Constructor.

        Args:
            channel: A grpc.Channel.
        """
        self.StreamIncoming = channel.unary_stream(
                '/greenlight.Node/StreamIncoming',
                request_serializer=greenlight__pb2.StreamIncomingFilter.SerializeToString,
                response_deserializer=greenlight__pb2.IncomingPayment.FromString,
                )
        self.StreamLog = channel.unary_stream(
                '/greenlight.Node/StreamLog',
                request_serializer=greenlight__pb2.StreamLogRequest.SerializeToString,
                response_deserializer=greenlight__pb2.LogEntry.FromString,
                )
        self.StreamCustommsg = channel.unary_stream(
                '/greenlight.Node/StreamCustommsg',
                request_serializer=greenlight__pb2.StreamCustommsgRequest.SerializeToString,
                response_deserializer=greenlight__pb2.Custommsg.FromString,
                )
        self.StreamHsmRequests = channel.unary_stream(
                '/greenlight.Node/StreamHsmRequests',
                request_serializer=greenlight__pb2.Empty.SerializeToString,
                response_deserializer=greenlight__pb2.HsmRequest.FromString,
                )
        self.RespondHsmRequest = channel.unary_unary(
                '/greenlight.Node/RespondHsmRequest',
                request_serializer=greenlight__pb2.HsmResponse.SerializeToString,
                response_deserializer=greenlight__pb2.Empty.FromString,
                )
        self.Configure = channel.unary_unary(
                '/greenlight.Node/Configure',
                request_serializer=greenlight__pb2.GlConfig.SerializeToString,
                response_deserializer=greenlight__pb2.Empty.FromString,
                )


class NodeServicer(object):
    """The node service represents your node running on greenlight's
    infrastructure. You can use the exposed RPC methods to interact
    with your node. The URI used to connect to the node depends on
    where the node is being scheduled and is returned by the
    `Scheduler.Schedule()` RPC call.

    Notice that in order to connect to the node the caller must use the
    node-specific mTLS keypair returned by `Scheduler.Register()` or
    `Scheduler.Recover()`. In particular the anonymous mTLS keypair is
    rejected by the node.

    Deprecated methods are being replaced by the standardized and
    automatically managed cln-grpc protocol you can find in
    `node.proto`
    """

    def StreamIncoming(self, request, context):
        """Stream incoming payments

        Currently includes off-chain payments received matching an
        invoice or spontaneus paymens through keysend.
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def StreamLog(self, request, context):
        """Stream the logs as they are produced by the node

        Mainly intended for debugging clients by tailing the log as
        they are written on the node. The logs start streaming from
        the first beginning, in order to allow inspection of events
        after an error occurred, That also means that the logs can
        be rather large, and should not be streamed onto
        resource-constrained devices.
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def StreamCustommsg(self, request, context):
        """Listen for incoming `custommsg` messages from peers.

        The messages are forwarded as they come in, and will not be
        replayed if the stream is interrupted.
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def StreamHsmRequests(self, request, context):
        """////////////////////////////// HSM Messages ////////////////////////

        The following messages are related to communicating HSM
        requests back and forth. Chances are you won't need to
        interact with these at all, unless you want to embed the
        hsmd into your client. We recommend using a standalone hsmd
        such as hagrid, keeper of keys, to get started.

        Stream requests from the node to any key device that can
        respond to them.
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def RespondHsmRequest(self, request, context):
        """Missing associated documentation comment in .proto file."""
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def Configure(self, request, context):
        """Missing associated documentation comment in .proto file."""
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')


def add_NodeServicer_to_server(servicer, server):
    rpc_method_handlers = {
            'StreamIncoming': grpc.unary_stream_rpc_method_handler(
                    servicer.StreamIncoming,
                    request_deserializer=greenlight__pb2.StreamIncomingFilter.FromString,
                    response_serializer=greenlight__pb2.IncomingPayment.SerializeToString,
            ),
            'StreamLog': grpc.unary_stream_rpc_method_handler(
                    servicer.StreamLog,
                    request_deserializer=greenlight__pb2.StreamLogRequest.FromString,
                    response_serializer=greenlight__pb2.LogEntry.SerializeToString,
            ),
            'StreamCustommsg': grpc.unary_stream_rpc_method_handler(
                    servicer.StreamCustommsg,
                    request_deserializer=greenlight__pb2.StreamCustommsgRequest.FromString,
                    response_serializer=greenlight__pb2.Custommsg.SerializeToString,
            ),
            'StreamHsmRequests': grpc.unary_stream_rpc_method_handler(
                    servicer.StreamHsmRequests,
                    request_deserializer=greenlight__pb2.Empty.FromString,
                    response_serializer=greenlight__pb2.HsmRequest.SerializeToString,
            ),
            'RespondHsmRequest': grpc.unary_unary_rpc_method_handler(
                    servicer.RespondHsmRequest,
                    request_deserializer=greenlight__pb2.HsmResponse.FromString,
                    response_serializer=greenlight__pb2.Empty.SerializeToString,
            ),
            'Configure': grpc.unary_unary_rpc_method_handler(
                    servicer.Configure,
                    request_deserializer=greenlight__pb2.GlConfig.FromString,
                    response_serializer=greenlight__pb2.Empty.SerializeToString,
            ),
    }
    generic_handler = grpc.method_handlers_generic_handler(
            'greenlight.Node', rpc_method_handlers)
    server.add_generic_rpc_handlers((generic_handler,))


 # This class is part of an EXPERIMENTAL API.
class Node(object):
    """The node service represents your node running on greenlight's
    infrastructure. You can use the exposed RPC methods to interact
    with your node. The URI used to connect to the node depends on
    where the node is being scheduled and is returned by the
    `Scheduler.Schedule()` RPC call.

    Notice that in order to connect to the node the caller must use the
    node-specific mTLS keypair returned by `Scheduler.Register()` or
    `Scheduler.Recover()`. In particular the anonymous mTLS keypair is
    rejected by the node.

    Deprecated methods are being replaced by the standardized and
    automatically managed cln-grpc protocol you can find in
    `node.proto`
    """

    @staticmethod
    def StreamIncoming(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_stream(request, target, '/greenlight.Node/StreamIncoming',
            greenlight__pb2.StreamIncomingFilter.SerializeToString,
            greenlight__pb2.IncomingPayment.FromString,
            options, channel_credentials,
            insecure, call_credentials, compression, wait_for_ready, timeout, metadata)

    @staticmethod
    def StreamLog(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_stream(request, target, '/greenlight.Node/StreamLog',
            greenlight__pb2.StreamLogRequest.SerializeToString,
            greenlight__pb2.LogEntry.FromString,
            options, channel_credentials,
            insecure, call_credentials, compression, wait_for_ready, timeout, metadata)

    @staticmethod
    def StreamCustommsg(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_stream(request, target, '/greenlight.Node/StreamCustommsg',
            greenlight__pb2.StreamCustommsgRequest.SerializeToString,
            greenlight__pb2.Custommsg.FromString,
            options, channel_credentials,
            insecure, call_credentials, compression, wait_for_ready, timeout, metadata)

    @staticmethod
    def StreamHsmRequests(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_stream(request, target, '/greenlight.Node/StreamHsmRequests',
            greenlight__pb2.Empty.SerializeToString,
            greenlight__pb2.HsmRequest.FromString,
            options, channel_credentials,
            insecure, call_credentials, compression, wait_for_ready, timeout, metadata)

    @staticmethod
    def RespondHsmRequest(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(request, target, '/greenlight.Node/RespondHsmRequest',
            greenlight__pb2.HsmResponse.SerializeToString,
            greenlight__pb2.Empty.FromString,
            options, channel_credentials,
            insecure, call_credentials, compression, wait_for_ready, timeout, metadata)

    @staticmethod
    def Configure(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(request, target, '/greenlight.Node/Configure',
            greenlight__pb2.GlConfig.SerializeToString,
            greenlight__pb2.Empty.FromString,
            options, channel_credentials,
            insecure, call_credentials, compression, wait_for_ready, timeout, metadata)


class HsmStub(object):
    """Missing associated documentation comment in .proto file."""

    def __init__(self, channel):
        """Constructor.

        Args:
            channel: A grpc.Channel.
        """
        self.Request = channel.unary_unary(
                '/greenlight.Hsm/Request',
                request_serializer=greenlight__pb2.HsmRequest.SerializeToString,
                response_deserializer=greenlight__pb2.HsmResponse.FromString,
                )
        self.Ping = channel.unary_unary(
                '/greenlight.Hsm/Ping',
                request_serializer=greenlight__pb2.Empty.SerializeToString,
                response_deserializer=greenlight__pb2.Empty.FromString,
                )


class HsmServicer(object):
    """Missing associated documentation comment in .proto file."""

    def Request(self, request, context):
        """Missing associated documentation comment in .proto file."""
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def Ping(self, request, context):
        """Missing associated documentation comment in .proto file."""
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')


def add_HsmServicer_to_server(servicer, server):
    rpc_method_handlers = {
            'Request': grpc.unary_unary_rpc_method_handler(
                    servicer.Request,
                    request_deserializer=greenlight__pb2.HsmRequest.FromString,
                    response_serializer=greenlight__pb2.HsmResponse.SerializeToString,
            ),
            'Ping': grpc.unary_unary_rpc_method_handler(
                    servicer.Ping,
                    request_deserializer=greenlight__pb2.Empty.FromString,
                    response_serializer=greenlight__pb2.Empty.SerializeToString,
            ),
    }
    generic_handler = grpc.method_handlers_generic_handler(
            'greenlight.Hsm', rpc_method_handlers)
    server.add_generic_rpc_handlers((generic_handler,))


 # This class is part of an EXPERIMENTAL API.
class Hsm(object):
    """Missing associated documentation comment in .proto file."""

    @staticmethod
    def Request(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(request, target, '/greenlight.Hsm/Request',
            greenlight__pb2.HsmRequest.SerializeToString,
            greenlight__pb2.HsmResponse.FromString,
            options, channel_credentials,
            insecure, call_credentials, compression, wait_for_ready, timeout, metadata)

    @staticmethod
    def Ping(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(request, target, '/greenlight.Hsm/Ping',
            greenlight__pb2.Empty.SerializeToString,
            greenlight__pb2.Empty.FromString,
            options, channel_credentials,
            insecure, call_credentials, compression, wait_for_ready, timeout, metadata)
