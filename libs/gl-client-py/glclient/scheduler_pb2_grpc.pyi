"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
"""

import abc
import collections.abc
import glclient.greenlight_pb2
import glclient.scheduler_pb2
import grpc
import grpc.aio
import typing

_T = typing.TypeVar("_T")

class _MaybeAsyncIterator(collections.abc.AsyncIterator[_T], collections.abc.Iterator[_T], metaclass=abc.ABCMeta): ...

class _ServicerContext(grpc.ServicerContext, grpc.aio.ServicerContext):  # type: ignore[misc, type-arg]
    ...

class SchedulerStub:
    """The scheduler service is the endpoint which allows users to
    register a new node with greenlight, recover access to an existing
    node if the owner lost its credentials, schedule the node to be run
    on greenlight's infrastructure, and retrieve metadata about the
    node.

    Node
    ====

    A node is the basic object representing an account on
    greenlight. Each node corresponds to a c-lightning instance bound
    to a specific network that can be scheduled on greenlight, and must
    have a unique `node_id`.

    Nodes are scheduled on-demand onto the infrastructure, but the time
    to schedule a node is almost instantaneous.

    Authentication
    ==============

    Users are authenticated using mTLS authentication. Applications are
    provisioned with an anonymous keypair that is not bound to a node,
    allowing access only to the unauthenticated endpoints
    `Scheduler.GetChallenge`, `Scheduler.Register` and
    `Scheduler.Recover`. This allows them to register or recover a
    node, but doesn't give access to the node itself. Upon registering
    or recovering an account the user receives a keypair that is bound
    to the specific node. Once the user receives their personal mTLS
    keypair they may use it to connect to greenlight, and thus get
    access to the node-specific functionality. Please refer to the
    documentation of your grpc library to learn how to configure grpc
    to use the node-specific mTLS keypair.
    """

    def __init__(self, channel: typing.Union[grpc.Channel, grpc.aio.Channel]) -> None: ...
    Register: grpc.UnaryUnaryMultiCallable[
        glclient.scheduler_pb2.RegistrationRequest,
        glclient.scheduler_pb2.RegistrationResponse,
    ]
    """A user may register a new node with greenlight by providing
    some basic metadata and proving that they have access to
    the corresponding private key (see challenge-response
    mechanism below). This means that in order to register a
    new node the user must have access to the corresponding
    private keys to prove ownership, and prevent users from
    just registering arbitrary node_ids without actually
    knowing the corresponding secrets.

    Upon successful registration an mTLS certificate and
    private key are returned. These can be used to authenticate
    future connections to the scheduler or the node.

    Each node may be registered once, any later attempt will
    result in an error being returned. If the user lost its
    credentials it can make use of the Recover RPC method to
    recover the credentials. Notice that this also means that
    the same node_id cannot be reused for different networks.
    """

    Recover: grpc.UnaryUnaryMultiCallable[
        glclient.scheduler_pb2.RecoveryRequest,
        glclient.scheduler_pb2.RecoveryResponse,
    ]
    """Should a user have lost its credentials (mTLS keypair) for
    any reason, they may regain access to their node using the
    Recover RPC method. Similar to the initial registration the
    caller needs to authenticate the call by proving access to
    the node's secret. This also uses the challenge-response
    mechanism.

    Upon success a newly generated mTLS certificate and private
    key are returned, allowing the user to authenticate going
    forward. Existing keypairs are not revoked, in order to
    avoid locking out other authenticated applications.
    """

    GetChallenge: grpc.UnaryUnaryMultiCallable[
        glclient.scheduler_pb2.ChallengeRequest,
        glclient.scheduler_pb2.ChallengeResponse,
    ]
    """Challenges are one-time values issued by the server, used
    to authenticate a user/device against the server. A user or
    device can authenticate to the server by signing the
    challenge and returning the signed message as part of the
    request that is to be authenticated.

    Challenges may not be reused, and are bound to the scope
    they have been issued for. Attempting to reuse a challenge
    or use a challenge with a different scope will result in an
    error being returned.
    """

    Schedule: grpc.UnaryUnaryMultiCallable[
        glclient.scheduler_pb2.ScheduleRequest,
        glclient.scheduler_pb2.NodeInfoResponse,
    ]
    """Scheduling takes a previously registered node, locates a
    free slot in greenlight's infrastructure and allocates it
    to run the node. The node then goes through the startup
    sequence, synchronizing with the blockchain, and finally
    binding its grpc interface (see Node service below) to a
    public IP address and port. Access is authenticated via the
    mTLS keypair the user received from registering or
    recovering the node.

    Upon success a NodeInfoResponse containing the grpc
    connection details and some metadata is returned. The
    application must use the grpc details and its node-specific
    mTLS keypair to interact with the node directly.
    """

    GetNodeInfo: grpc.UnaryUnaryMultiCallable[
        glclient.scheduler_pb2.NodeInfoRequest,
        glclient.scheduler_pb2.NodeInfoResponse,
    ]
    """Much like `Schedule` this call is used to retrieve the
    metadata and grpc details of a node. Unlike the other call
    however it is passive, and will not result in the node
    being scheduled if it isn't already running. This can be
    used to check if a node is already scheduled, or to wait
    for it to be scheduled (e.g., if the caller is an `hsmd`
    that signs off on changes, but doesn't want to keep the
    node itself scheduled).
    """

    MaybeUpgrade: grpc.UnaryUnaryMultiCallable[
        glclient.scheduler_pb2.UpgradeRequest,
        glclient.scheduler_pb2.UpgradeResponse,
    ]
    """The signer may want to trigger an upgrade of the node
    before waiting for the node to be scheduled. This ensures
    that the signer version is in sync with the node
    version. The scheduler may decide to defer upgrading if the
    protocols are compatible. Please do not use this directly,
    rather use the Signer in the client library to trigger this
    automatically when required. Posting an incomplete or
    non-functional UpgradeRequest may result in unschedulable
    nodes.
    """

    ListInviteCodes: grpc.UnaryUnaryMultiCallable[
        glclient.scheduler_pb2.ListInviteCodesRequest,
        glclient.scheduler_pb2.ListInviteCodesResponse,
    ]
    """This call is used to fetch a list of invite codes associated
    with the node id of the client. These invite codes can be used
    for further registration of new nodes.
    """

    ExportNode: grpc.UnaryUnaryMultiCallable[
        glclient.scheduler_pb2.ExportNodeRequest,
        glclient.scheduler_pb2.ExportNodeResponse,
    ]
    """Exporting a node allows users to take control of their node

    This method initiates the node export on Greenlight,
    allowing users to offboard from GL into their own
    infrastructure. After calling this method the node will no
    longer be schedulable on Greenlight, since it is never safe
    to assume there haven't been changes in the node's state
    (see CLN Backups documentation for details). `ExportNode`
    marks the node as `Exporting`, then generates an encryption
    secret which is then used to encrypt a database
    backup. This encrypted database backup is then made
    accessible through an HTTP server, and a link to it is
    returned as a response to `ExportNode`. After the export
    completes the node is marked as `Exported`. The encryption
    key can then be derived using the signer, using ECDH,
    allowing only users with the node secret to decrypt it.

    `ExportNode` is idempotent and may be called multiple
    times, without causing the node to be re-exported multiple
    times, should the call or the download be interrupted. DO
    NOT import the backup multiple times into your
    infrastructure, as that can lead to dataloss (old state
    being replayed) and loss of funds (see CLN Backups
    documentation for more information)
    """

    AddOutgoingWebhook: grpc.UnaryUnaryMultiCallable[
        glclient.scheduler_pb2.AddOutgoingWebhookRequest,
        glclient.scheduler_pb2.AddOutgoingWebhookResponse,
    ]

    ListOutgoingWebhooks: grpc.UnaryUnaryMultiCallable[
        glclient.scheduler_pb2.ListOutgoingWebhooksRequest,
        glclient.scheduler_pb2.ListOutgoingWebhooksResponse,
    ]

    DeleteWebhooks: grpc.UnaryUnaryMultiCallable[
        glclient.scheduler_pb2.DeleteOutgoingWebhooksRequest,
        glclient.greenlight_pb2.Empty,
    ]

    RotateOutgoingWebhookSecret: grpc.UnaryUnaryMultiCallable[
        glclient.scheduler_pb2.RotateOutgoingWebhookSecretRequest,
        glclient.scheduler_pb2.WebhookSecretResponse,
    ]

    SignerRequestsStream: grpc.StreamStreamMultiCallable[
        glclient.scheduler_pb2.SignerResponse,
        glclient.scheduler_pb2.SignerRequest,
    ]
    """Attaches a Signer  via a bidirectional stream to the scheduler. 
    This is a communication channel between greenlight and the signing
    device that is used for requests that are not part of the node api.

    The stream is used to hand out the ApprovePairingRequests that
    the signer answers with a ApprovePairingResponse.
    """

class SchedulerAsyncStub:
    """The scheduler service is the endpoint which allows users to
    register a new node with greenlight, recover access to an existing
    node if the owner lost its credentials, schedule the node to be run
    on greenlight's infrastructure, and retrieve metadata about the
    node.

    Node
    ====

    A node is the basic object representing an account on
    greenlight. Each node corresponds to a c-lightning instance bound
    to a specific network that can be scheduled on greenlight, and must
    have a unique `node_id`.

    Nodes are scheduled on-demand onto the infrastructure, but the time
    to schedule a node is almost instantaneous.

    Authentication
    ==============

    Users are authenticated using mTLS authentication. Applications are
    provisioned with an anonymous keypair that is not bound to a node,
    allowing access only to the unauthenticated endpoints
    `Scheduler.GetChallenge`, `Scheduler.Register` and
    `Scheduler.Recover`. This allows them to register or recover a
    node, but doesn't give access to the node itself. Upon registering
    or recovering an account the user receives a keypair that is bound
    to the specific node. Once the user receives their personal mTLS
    keypair they may use it to connect to greenlight, and thus get
    access to the node-specific functionality. Please refer to the
    documentation of your grpc library to learn how to configure grpc
    to use the node-specific mTLS keypair.
    """

    Register: grpc.aio.UnaryUnaryMultiCallable[
        glclient.scheduler_pb2.RegistrationRequest,
        glclient.scheduler_pb2.RegistrationResponse,
    ]
    """A user may register a new node with greenlight by providing
    some basic metadata and proving that they have access to
    the corresponding private key (see challenge-response
    mechanism below). This means that in order to register a
    new node the user must have access to the corresponding
    private keys to prove ownership, and prevent users from
    just registering arbitrary node_ids without actually
    knowing the corresponding secrets.

    Upon successful registration an mTLS certificate and
    private key are returned. These can be used to authenticate
    future connections to the scheduler or the node.

    Each node may be registered once, any later attempt will
    result in an error being returned. If the user lost its
    credentials it can make use of the Recover RPC method to
    recover the credentials. Notice that this also means that
    the same node_id cannot be reused for different networks.
    """

    Recover: grpc.aio.UnaryUnaryMultiCallable[
        glclient.scheduler_pb2.RecoveryRequest,
        glclient.scheduler_pb2.RecoveryResponse,
    ]
    """Should a user have lost its credentials (mTLS keypair) for
    any reason, they may regain access to their node using the
    Recover RPC method. Similar to the initial registration the
    caller needs to authenticate the call by proving access to
    the node's secret. This also uses the challenge-response
    mechanism.

    Upon success a newly generated mTLS certificate and private
    key are returned, allowing the user to authenticate going
    forward. Existing keypairs are not revoked, in order to
    avoid locking out other authenticated applications.
    """

    GetChallenge: grpc.aio.UnaryUnaryMultiCallable[
        glclient.scheduler_pb2.ChallengeRequest,
        glclient.scheduler_pb2.ChallengeResponse,
    ]
    """Challenges are one-time values issued by the server, used
    to authenticate a user/device against the server. A user or
    device can authenticate to the server by signing the
    challenge and returning the signed message as part of the
    request that is to be authenticated.

    Challenges may not be reused, and are bound to the scope
    they have been issued for. Attempting to reuse a challenge
    or use a challenge with a different scope will result in an
    error being returned.
    """

    Schedule: grpc.aio.UnaryUnaryMultiCallable[
        glclient.scheduler_pb2.ScheduleRequest,
        glclient.scheduler_pb2.NodeInfoResponse,
    ]
    """Scheduling takes a previously registered node, locates a
    free slot in greenlight's infrastructure and allocates it
    to run the node. The node then goes through the startup
    sequence, synchronizing with the blockchain, and finally
    binding its grpc interface (see Node service below) to a
    public IP address and port. Access is authenticated via the
    mTLS keypair the user received from registering or
    recovering the node.

    Upon success a NodeInfoResponse containing the grpc
    connection details and some metadata is returned. The
    application must use the grpc details and its node-specific
    mTLS keypair to interact with the node directly.
    """

    GetNodeInfo: grpc.aio.UnaryUnaryMultiCallable[
        glclient.scheduler_pb2.NodeInfoRequest,
        glclient.scheduler_pb2.NodeInfoResponse,
    ]
    """Much like `Schedule` this call is used to retrieve the
    metadata and grpc details of a node. Unlike the other call
    however it is passive, and will not result in the node
    being scheduled if it isn't already running. This can be
    used to check if a node is already scheduled, or to wait
    for it to be scheduled (e.g., if the caller is an `hsmd`
    that signs off on changes, but doesn't want to keep the
    node itself scheduled).
    """

    MaybeUpgrade: grpc.aio.UnaryUnaryMultiCallable[
        glclient.scheduler_pb2.UpgradeRequest,
        glclient.scheduler_pb2.UpgradeResponse,
    ]
    """The signer may want to trigger an upgrade of the node
    before waiting for the node to be scheduled. This ensures
    that the signer version is in sync with the node
    version. The scheduler may decide to defer upgrading if the
    protocols are compatible. Please do not use this directly,
    rather use the Signer in the client library to trigger this
    automatically when required. Posting an incomplete or
    non-functional UpgradeRequest may result in unschedulable
    nodes.
    """

    ListInviteCodes: grpc.aio.UnaryUnaryMultiCallable[
        glclient.scheduler_pb2.ListInviteCodesRequest,
        glclient.scheduler_pb2.ListInviteCodesResponse,
    ]
    """This call is used to fetch a list of invite codes associated
    with the node id of the client. These invite codes can be used
    for further registration of new nodes.
    """

    ExportNode: grpc.aio.UnaryUnaryMultiCallable[
        glclient.scheduler_pb2.ExportNodeRequest,
        glclient.scheduler_pb2.ExportNodeResponse,
    ]
    """Exporting a node allows users to take control of their node

    This method initiates the node export on Greenlight,
    allowing users to offboard from GL into their own
    infrastructure. After calling this method the node will no
    longer be schedulable on Greenlight, since it is never safe
    to assume there haven't been changes in the node's state
    (see CLN Backups documentation for details). `ExportNode`
    marks the node as `Exporting`, then generates an encryption
    secret which is then used to encrypt a database
    backup. This encrypted database backup is then made
    accessible through an HTTP server, and a link to it is
    returned as a response to `ExportNode`. After the export
    completes the node is marked as `Exported`. The encryption
    key can then be derived using the signer, using ECDH,
    allowing only users with the node secret to decrypt it.

    `ExportNode` is idempotent and may be called multiple
    times, without causing the node to be re-exported multiple
    times, should the call or the download be interrupted. DO
    NOT import the backup multiple times into your
    infrastructure, as that can lead to dataloss (old state
    being replayed) and loss of funds (see CLN Backups
    documentation for more information)
    """

    AddOutgoingWebhook: grpc.aio.UnaryUnaryMultiCallable[
        glclient.scheduler_pb2.AddOutgoingWebhookRequest,
        glclient.scheduler_pb2.AddOutgoingWebhookResponse,
    ]

    ListOutgoingWebhooks: grpc.aio.UnaryUnaryMultiCallable[
        glclient.scheduler_pb2.ListOutgoingWebhooksRequest,
        glclient.scheduler_pb2.ListOutgoingWebhooksResponse,
    ]

    DeleteWebhooks: grpc.aio.UnaryUnaryMultiCallable[
        glclient.scheduler_pb2.DeleteOutgoingWebhooksRequest,
        glclient.greenlight_pb2.Empty,
    ]

    RotateOutgoingWebhookSecret: grpc.aio.UnaryUnaryMultiCallable[
        glclient.scheduler_pb2.RotateOutgoingWebhookSecretRequest,
        glclient.scheduler_pb2.WebhookSecretResponse,
    ]

    SignerRequestsStream: grpc.aio.StreamStreamMultiCallable[
        glclient.scheduler_pb2.SignerResponse,
        glclient.scheduler_pb2.SignerRequest,
    ]
    """Attaches a Signer  via a bidirectional stream to the scheduler. 
    This is a communication channel between greenlight and the signing
    device that is used for requests that are not part of the node api.

    The stream is used to hand out the ApprovePairingRequests that
    the signer answers with a ApprovePairingResponse.
    """

class SchedulerServicer(metaclass=abc.ABCMeta):
    """The scheduler service is the endpoint which allows users to
    register a new node with greenlight, recover access to an existing
    node if the owner lost its credentials, schedule the node to be run
    on greenlight's infrastructure, and retrieve metadata about the
    node.

    Node
    ====

    A node is the basic object representing an account on
    greenlight. Each node corresponds to a c-lightning instance bound
    to a specific network that can be scheduled on greenlight, and must
    have a unique `node_id`.

    Nodes are scheduled on-demand onto the infrastructure, but the time
    to schedule a node is almost instantaneous.

    Authentication
    ==============

    Users are authenticated using mTLS authentication. Applications are
    provisioned with an anonymous keypair that is not bound to a node,
    allowing access only to the unauthenticated endpoints
    `Scheduler.GetChallenge`, `Scheduler.Register` and
    `Scheduler.Recover`. This allows them to register or recover a
    node, but doesn't give access to the node itself. Upon registering
    or recovering an account the user receives a keypair that is bound
    to the specific node. Once the user receives their personal mTLS
    keypair they may use it to connect to greenlight, and thus get
    access to the node-specific functionality. Please refer to the
    documentation of your grpc library to learn how to configure grpc
    to use the node-specific mTLS keypair.
    """

    @abc.abstractmethod
    def Register(
        self,
        request: glclient.scheduler_pb2.RegistrationRequest,
        context: _ServicerContext,
    ) -> typing.Union[glclient.scheduler_pb2.RegistrationResponse, collections.abc.Awaitable[glclient.scheduler_pb2.RegistrationResponse]]:
        """A user may register a new node with greenlight by providing
        some basic metadata and proving that they have access to
        the corresponding private key (see challenge-response
        mechanism below). This means that in order to register a
        new node the user must have access to the corresponding
        private keys to prove ownership, and prevent users from
        just registering arbitrary node_ids without actually
        knowing the corresponding secrets.

        Upon successful registration an mTLS certificate and
        private key are returned. These can be used to authenticate
        future connections to the scheduler or the node.

        Each node may be registered once, any later attempt will
        result in an error being returned. If the user lost its
        credentials it can make use of the Recover RPC method to
        recover the credentials. Notice that this also means that
        the same node_id cannot be reused for different networks.
        """

    @abc.abstractmethod
    def Recover(
        self,
        request: glclient.scheduler_pb2.RecoveryRequest,
        context: _ServicerContext,
    ) -> typing.Union[glclient.scheduler_pb2.RecoveryResponse, collections.abc.Awaitable[glclient.scheduler_pb2.RecoveryResponse]]:
        """Should a user have lost its credentials (mTLS keypair) for
        any reason, they may regain access to their node using the
        Recover RPC method. Similar to the initial registration the
        caller needs to authenticate the call by proving access to
        the node's secret. This also uses the challenge-response
        mechanism.

        Upon success a newly generated mTLS certificate and private
        key are returned, allowing the user to authenticate going
        forward. Existing keypairs are not revoked, in order to
        avoid locking out other authenticated applications.
        """

    @abc.abstractmethod
    def GetChallenge(
        self,
        request: glclient.scheduler_pb2.ChallengeRequest,
        context: _ServicerContext,
    ) -> typing.Union[glclient.scheduler_pb2.ChallengeResponse, collections.abc.Awaitable[glclient.scheduler_pb2.ChallengeResponse]]:
        """Challenges are one-time values issued by the server, used
        to authenticate a user/device against the server. A user or
        device can authenticate to the server by signing the
        challenge and returning the signed message as part of the
        request that is to be authenticated.

        Challenges may not be reused, and are bound to the scope
        they have been issued for. Attempting to reuse a challenge
        or use a challenge with a different scope will result in an
        error being returned.
        """

    @abc.abstractmethod
    def Schedule(
        self,
        request: glclient.scheduler_pb2.ScheduleRequest,
        context: _ServicerContext,
    ) -> typing.Union[glclient.scheduler_pb2.NodeInfoResponse, collections.abc.Awaitable[glclient.scheduler_pb2.NodeInfoResponse]]:
        """Scheduling takes a previously registered node, locates a
        free slot in greenlight's infrastructure and allocates it
        to run the node. The node then goes through the startup
        sequence, synchronizing with the blockchain, and finally
        binding its grpc interface (see Node service below) to a
        public IP address and port. Access is authenticated via the
        mTLS keypair the user received from registering or
        recovering the node.

        Upon success a NodeInfoResponse containing the grpc
        connection details and some metadata is returned. The
        application must use the grpc details and its node-specific
        mTLS keypair to interact with the node directly.
        """

    @abc.abstractmethod
    def GetNodeInfo(
        self,
        request: glclient.scheduler_pb2.NodeInfoRequest,
        context: _ServicerContext,
    ) -> typing.Union[glclient.scheduler_pb2.NodeInfoResponse, collections.abc.Awaitable[glclient.scheduler_pb2.NodeInfoResponse]]:
        """Much like `Schedule` this call is used to retrieve the
        metadata and grpc details of a node. Unlike the other call
        however it is passive, and will not result in the node
        being scheduled if it isn't already running. This can be
        used to check if a node is already scheduled, or to wait
        for it to be scheduled (e.g., if the caller is an `hsmd`
        that signs off on changes, but doesn't want to keep the
        node itself scheduled).
        """

    @abc.abstractmethod
    def MaybeUpgrade(
        self,
        request: glclient.scheduler_pb2.UpgradeRequest,
        context: _ServicerContext,
    ) -> typing.Union[glclient.scheduler_pb2.UpgradeResponse, collections.abc.Awaitable[glclient.scheduler_pb2.UpgradeResponse]]:
        """The signer may want to trigger an upgrade of the node
        before waiting for the node to be scheduled. This ensures
        that the signer version is in sync with the node
        version. The scheduler may decide to defer upgrading if the
        protocols are compatible. Please do not use this directly,
        rather use the Signer in the client library to trigger this
        automatically when required. Posting an incomplete or
        non-functional UpgradeRequest may result in unschedulable
        nodes.
        """

    @abc.abstractmethod
    def ListInviteCodes(
        self,
        request: glclient.scheduler_pb2.ListInviteCodesRequest,
        context: _ServicerContext,
    ) -> typing.Union[glclient.scheduler_pb2.ListInviteCodesResponse, collections.abc.Awaitable[glclient.scheduler_pb2.ListInviteCodesResponse]]:
        """This call is used to fetch a list of invite codes associated
        with the node id of the client. These invite codes can be used
        for further registration of new nodes.
        """

    @abc.abstractmethod
    def ExportNode(
        self,
        request: glclient.scheduler_pb2.ExportNodeRequest,
        context: _ServicerContext,
    ) -> typing.Union[glclient.scheduler_pb2.ExportNodeResponse, collections.abc.Awaitable[glclient.scheduler_pb2.ExportNodeResponse]]:
        """Exporting a node allows users to take control of their node

        This method initiates the node export on Greenlight,
        allowing users to offboard from GL into their own
        infrastructure. After calling this method the node will no
        longer be schedulable on Greenlight, since it is never safe
        to assume there haven't been changes in the node's state
        (see CLN Backups documentation for details). `ExportNode`
        marks the node as `Exporting`, then generates an encryption
        secret which is then used to encrypt a database
        backup. This encrypted database backup is then made
        accessible through an HTTP server, and a link to it is
        returned as a response to `ExportNode`. After the export
        completes the node is marked as `Exported`. The encryption
        key can then be derived using the signer, using ECDH,
        allowing only users with the node secret to decrypt it.

        `ExportNode` is idempotent and may be called multiple
        times, without causing the node to be re-exported multiple
        times, should the call or the download be interrupted. DO
        NOT import the backup multiple times into your
        infrastructure, as that can lead to dataloss (old state
        being replayed) and loss of funds (see CLN Backups
        documentation for more information)
        """

    @abc.abstractmethod
    def AddOutgoingWebhook(
        self,
        request: glclient.scheduler_pb2.AddOutgoingWebhookRequest,
        context: _ServicerContext,
    ) -> typing.Union[glclient.scheduler_pb2.AddOutgoingWebhookResponse, collections.abc.Awaitable[glclient.scheduler_pb2.AddOutgoingWebhookResponse]]: ...

    @abc.abstractmethod
    def ListOutgoingWebhooks(
        self,
        request: glclient.scheduler_pb2.ListOutgoingWebhooksRequest,
        context: _ServicerContext,
    ) -> typing.Union[glclient.scheduler_pb2.ListOutgoingWebhooksResponse, collections.abc.Awaitable[glclient.scheduler_pb2.ListOutgoingWebhooksResponse]]: ...

    @abc.abstractmethod
    def DeleteWebhooks(
        self,
        request: glclient.scheduler_pb2.DeleteOutgoingWebhooksRequest,
        context: _ServicerContext,
    ) -> typing.Union[glclient.greenlight_pb2.Empty, collections.abc.Awaitable[glclient.greenlight_pb2.Empty]]: ...

    @abc.abstractmethod
    def RotateOutgoingWebhookSecret(
        self,
        request: glclient.scheduler_pb2.RotateOutgoingWebhookSecretRequest,
        context: _ServicerContext,
    ) -> typing.Union[glclient.scheduler_pb2.WebhookSecretResponse, collections.abc.Awaitable[glclient.scheduler_pb2.WebhookSecretResponse]]: ...

    @abc.abstractmethod
    def SignerRequestsStream(
        self,
        request_iterator: _MaybeAsyncIterator[glclient.scheduler_pb2.SignerResponse],
        context: _ServicerContext,
    ) -> typing.Union[collections.abc.Iterator[glclient.scheduler_pb2.SignerRequest], collections.abc.AsyncIterator[glclient.scheduler_pb2.SignerRequest]]:
        """Attaches a Signer  via a bidirectional stream to the scheduler. 
        This is a communication channel between greenlight and the signing
        device that is used for requests that are not part of the node api.

        The stream is used to hand out the ApprovePairingRequests that
        the signer answers with a ApprovePairingResponse.
        """

def add_SchedulerServicer_to_server(servicer: SchedulerServicer, server: typing.Union[grpc.Server, grpc.aio.Server]) -> None: ...

class DebugStub:
    """A service to collect debugging information from clients."""

    def __init__(self, channel: typing.Union[grpc.Channel, grpc.aio.Channel]) -> None: ...
    ReportSignerRejection: grpc.UnaryUnaryMultiCallable[
        glclient.scheduler_pb2.SignerRejection,
        glclient.greenlight_pb2.Empty,
    ]
    """The signer is designed to fail closed, i.e., we reject requests
    that do not resolve or that go against one of its policies. This
    comes with some issues, such as false negatives, where we reject
    despite the request being valid. As more apps use the API we need
    to debug these false negatives, hence why we report rejections,
    so we can investigate the validity of the rejection, and to
    fine-tine the signer's ruleset.
    """

class DebugAsyncStub:
    """A service to collect debugging information from clients."""

    ReportSignerRejection: grpc.aio.UnaryUnaryMultiCallable[
        glclient.scheduler_pb2.SignerRejection,
        glclient.greenlight_pb2.Empty,
    ]
    """The signer is designed to fail closed, i.e., we reject requests
    that do not resolve or that go against one of its policies. This
    comes with some issues, such as false negatives, where we reject
    despite the request being valid. As more apps use the API we need
    to debug these false negatives, hence why we report rejections,
    so we can investigate the validity of the rejection, and to
    fine-tine the signer's ruleset.
    """

class DebugServicer(metaclass=abc.ABCMeta):
    """A service to collect debugging information from clients."""

    @abc.abstractmethod
    def ReportSignerRejection(
        self,
        request: glclient.scheduler_pb2.SignerRejection,
        context: _ServicerContext,
    ) -> typing.Union[glclient.greenlight_pb2.Empty, collections.abc.Awaitable[glclient.greenlight_pb2.Empty]]:
        """The signer is designed to fail closed, i.e., we reject requests
        that do not resolve or that go against one of its policies. This
        comes with some issues, such as false negatives, where we reject
        despite the request being valid. As more apps use the API we need
        to debug these false negatives, hence why we report rejections,
        so we can investigate the validity of the rejection, and to
        fine-tine the signer's ruleset.
        """

def add_DebugServicer_to_server(servicer: DebugServicer, server: typing.Union[grpc.Server, grpc.aio.Server]) -> None: ...

class PairingStub:
    """A service to pair signer-less clients with an existing signer."""

    def __init__(self, channel: typing.Union[grpc.Channel, grpc.aio.Channel]) -> None: ...
    PairDevice: grpc.UnaryUnaryMultiCallable[
        glclient.scheduler_pb2.PairDeviceRequest,
        glclient.scheduler_pb2.PairDeviceResponse,
    ]
    """Initiates a new Pairing Sessions. This is called by the new
    device that wants to request a pairing from an existing device.
    The session lifetime is bound to the stream so closing the
    stream destroys the session.
    """

    GetPairingData: grpc.UnaryUnaryMultiCallable[
        glclient.scheduler_pb2.GetPairingDataRequest,
        glclient.scheduler_pb2.GetPairingDataResponse,
    ]
    """Returns the pairing related data that belongs to a pairing
    session. This is meant to be called from a device that can
    approve a pairing request, we sometimes call it "old device".
    """

    ApprovePairing: grpc.UnaryUnaryMultiCallable[
        glclient.scheduler_pb2.ApprovePairingRequest,
        glclient.greenlight_pb2.Empty,
    ]
    """Approves a pairing request. The ApprovePairingRequest is
    forwarded to a signer for further processing.
    """

class PairingAsyncStub:
    """A service to pair signer-less clients with an existing signer."""

    PairDevice: grpc.aio.UnaryUnaryMultiCallable[
        glclient.scheduler_pb2.PairDeviceRequest,
        glclient.scheduler_pb2.PairDeviceResponse,
    ]
    """Initiates a new Pairing Sessions. This is called by the new
    device that wants to request a pairing from an existing device.
    The session lifetime is bound to the stream so closing the
    stream destroys the session.
    """

    GetPairingData: grpc.aio.UnaryUnaryMultiCallable[
        glclient.scheduler_pb2.GetPairingDataRequest,
        glclient.scheduler_pb2.GetPairingDataResponse,
    ]
    """Returns the pairing related data that belongs to a pairing
    session. This is meant to be called from a device that can
    approve a pairing request, we sometimes call it "old device".
    """

    ApprovePairing: grpc.aio.UnaryUnaryMultiCallable[
        glclient.scheduler_pb2.ApprovePairingRequest,
        glclient.greenlight_pb2.Empty,
    ]
    """Approves a pairing request. The ApprovePairingRequest is
    forwarded to a signer for further processing.
    """

class PairingServicer(metaclass=abc.ABCMeta):
    """A service to pair signer-less clients with an existing signer."""

    @abc.abstractmethod
    def PairDevice(
        self,
        request: glclient.scheduler_pb2.PairDeviceRequest,
        context: _ServicerContext,
    ) -> typing.Union[glclient.scheduler_pb2.PairDeviceResponse, collections.abc.Awaitable[glclient.scheduler_pb2.PairDeviceResponse]]:
        """Initiates a new Pairing Sessions. This is called by the new
        device that wants to request a pairing from an existing device.
        The session lifetime is bound to the stream so closing the
        stream destroys the session.
        """

    @abc.abstractmethod
    def GetPairingData(
        self,
        request: glclient.scheduler_pb2.GetPairingDataRequest,
        context: _ServicerContext,
    ) -> typing.Union[glclient.scheduler_pb2.GetPairingDataResponse, collections.abc.Awaitable[glclient.scheduler_pb2.GetPairingDataResponse]]:
        """Returns the pairing related data that belongs to a pairing
        session. This is meant to be called from a device that can
        approve a pairing request, we sometimes call it "old device".
        """

    @abc.abstractmethod
    def ApprovePairing(
        self,
        request: glclient.scheduler_pb2.ApprovePairingRequest,
        context: _ServicerContext,
    ) -> typing.Union[glclient.greenlight_pb2.Empty, collections.abc.Awaitable[glclient.greenlight_pb2.Empty]]:
        """Approves a pairing request. The ApprovePairingRequest is
        forwarded to a signer for further processing.
        """

def add_PairingServicer_to_server(servicer: PairingServicer, server: typing.Union[grpc.Server, grpc.aio.Server]) -> None: ...
