# Generated by the gRPC Python protocol compiler plugin. DO NOT EDIT!
"""Client and server classes corresponding to protobuf-defined services."""
import grpc
import warnings

from glclient import greenlight_pb2 as glclient_dot_greenlight__pb2
from glclient import scheduler_pb2 as glclient_dot_scheduler__pb2

GRPC_GENERATED_VERSION = '1.64.1'
GRPC_VERSION = grpc.__version__
EXPECTED_ERROR_RELEASE = '1.65.0'
SCHEDULED_RELEASE_DATE = 'June 25, 2024'
_version_not_supported = False

try:
    from grpc._utilities import first_version_is_lower
    _version_not_supported = first_version_is_lower(GRPC_VERSION, GRPC_GENERATED_VERSION)
except ImportError:
    _version_not_supported = True

if _version_not_supported:
    warnings.warn(
        f'The grpc package installed is at version {GRPC_VERSION},'
        + f' but the generated code in glclient/scheduler_pb2_grpc.py depends on'
        + f' grpcio>={GRPC_GENERATED_VERSION}.'
        + f' Please upgrade your grpc module to grpcio>={GRPC_GENERATED_VERSION}'
        + f' or downgrade your generated code using grpcio-tools<={GRPC_VERSION}.'
        + f' This warning will become an error in {EXPECTED_ERROR_RELEASE},'
        + f' scheduled for release on {SCHEDULED_RELEASE_DATE}.',
        RuntimeWarning
    )


class SchedulerStub(object):
    """The scheduler service is the endpoint which allows users to
    register a new node with greenlight, recover access to an existing
    node if the owner lost its credentials, schedule the node to be run
    on greenlight's infrastructure, and retrieve metadata about the
    node.

    Node
    ====

    A node is the basic object representing an account on
    greenlight. Each node corresponds to a c-lightning instance bound
    to a specific network that can be scheduled on greenlight, and must
    have a unique `node_id`.

    Nodes are scheduled on-demand onto the infrastructure, but the time
    to schedule a node is almost instantaneous.

    Authentication
    ==============

    Users are authenticated using mTLS authentication. Applications are
    provisioned with an anonymous keypair that is not bound to a node,
    allowing access only to the unauthenticated endpoints
    `Scheduler.GetChallenge`, `Scheduler.Register` and
    `Scheduler.Recover`. This allows them to register or recover a
    node, but doesn't give access to the node itself. Upon registering
    or recovering an account the user receives a keypair that is bound
    to the specific node. Once the user receives their personal mTLS
    keypair they may use it to connect to greenlight, and thus get
    access to the node-specific functionality. Please refer to the
    documentation of your grpc library to learn how to configure grpc
    to use the node-specific mTLS keypair.

    """

    def __init__(self, channel):
        """Constructor.

        Args:
            channel: A grpc.Channel.
        """
        self.Register = channel.unary_unary(
                '/scheduler.Scheduler/Register',
                request_serializer=glclient_dot_scheduler__pb2.RegistrationRequest.SerializeToString,
                response_deserializer=glclient_dot_scheduler__pb2.RegistrationResponse.FromString,
                _registered_method=True)
        self.Recover = channel.unary_unary(
                '/scheduler.Scheduler/Recover',
                request_serializer=glclient_dot_scheduler__pb2.RecoveryRequest.SerializeToString,
                response_deserializer=glclient_dot_scheduler__pb2.RecoveryResponse.FromString,
                _registered_method=True)
        self.GetChallenge = channel.unary_unary(
                '/scheduler.Scheduler/GetChallenge',
                request_serializer=glclient_dot_scheduler__pb2.ChallengeRequest.SerializeToString,
                response_deserializer=glclient_dot_scheduler__pb2.ChallengeResponse.FromString,
                _registered_method=True)
        self.Schedule = channel.unary_unary(
                '/scheduler.Scheduler/Schedule',
                request_serializer=glclient_dot_scheduler__pb2.ScheduleRequest.SerializeToString,
                response_deserializer=glclient_dot_scheduler__pb2.NodeInfoResponse.FromString,
                _registered_method=True)
        self.GetNodeInfo = channel.unary_unary(
                '/scheduler.Scheduler/GetNodeInfo',
                request_serializer=glclient_dot_scheduler__pb2.NodeInfoRequest.SerializeToString,
                response_deserializer=glclient_dot_scheduler__pb2.NodeInfoResponse.FromString,
                _registered_method=True)
        self.MaybeUpgrade = channel.unary_unary(
                '/scheduler.Scheduler/MaybeUpgrade',
                request_serializer=glclient_dot_scheduler__pb2.UpgradeRequest.SerializeToString,
                response_deserializer=glclient_dot_scheduler__pb2.UpgradeResponse.FromString,
                _registered_method=True)
        self.ListInviteCodes = channel.unary_unary(
                '/scheduler.Scheduler/ListInviteCodes',
                request_serializer=glclient_dot_scheduler__pb2.ListInviteCodesRequest.SerializeToString,
                response_deserializer=glclient_dot_scheduler__pb2.ListInviteCodesResponse.FromString,
                _registered_method=True)
        self.ExportNode = channel.unary_unary(
                '/scheduler.Scheduler/ExportNode',
                request_serializer=glclient_dot_scheduler__pb2.ExportNodeRequest.SerializeToString,
                response_deserializer=glclient_dot_scheduler__pb2.ExportNodeResponse.FromString,
                _registered_method=True)
        self.AddOutgoingWebhook = channel.unary_unary(
                '/scheduler.Scheduler/AddOutgoingWebhook',
                request_serializer=glclient_dot_scheduler__pb2.AddOutgoingWebhookRequest.SerializeToString,
                response_deserializer=glclient_dot_scheduler__pb2.AddOutgoingWebhookResponse.FromString,
                _registered_method=True)
        self.ListOutgoingWebhooks = channel.unary_unary(
                '/scheduler.Scheduler/ListOutgoingWebhooks',
                request_serializer=glclient_dot_scheduler__pb2.ListOutgoingWebhooksRequest.SerializeToString,
                response_deserializer=glclient_dot_scheduler__pb2.ListOutgoingWebhooksResponse.FromString,
                _registered_method=True)
        self.DeleteWebhooks = channel.unary_unary(
                '/scheduler.Scheduler/DeleteWebhooks',
                request_serializer=glclient_dot_scheduler__pb2.DeleteOutgoingWebhooksRequest.SerializeToString,
                response_deserializer=glclient_dot_greenlight__pb2.Empty.FromString,
                _registered_method=True)
        self.RotateOutgoingWebhookSecret = channel.unary_unary(
                '/scheduler.Scheduler/RotateOutgoingWebhookSecret',
                request_serializer=glclient_dot_scheduler__pb2.RotateOutgoingWebhookSecretRequest.SerializeToString,
                response_deserializer=glclient_dot_scheduler__pb2.WebhookSecretResponse.FromString,
                _registered_method=True)
        self.SignerRequestsStream = channel.stream_stream(
                '/scheduler.Scheduler/SignerRequestsStream',
                request_serializer=glclient_dot_scheduler__pb2.SignerResponse.SerializeToString,
                response_deserializer=glclient_dot_scheduler__pb2.SignerRequest.FromString,
                _registered_method=True)


class SchedulerServicer(object):
    """The scheduler service is the endpoint which allows users to
    register a new node with greenlight, recover access to an existing
    node if the owner lost its credentials, schedule the node to be run
    on greenlight's infrastructure, and retrieve metadata about the
    node.

    Node
    ====

    A node is the basic object representing an account on
    greenlight. Each node corresponds to a c-lightning instance bound
    to a specific network that can be scheduled on greenlight, and must
    have a unique `node_id`.

    Nodes are scheduled on-demand onto the infrastructure, but the time
    to schedule a node is almost instantaneous.

    Authentication
    ==============

    Users are authenticated using mTLS authentication. Applications are
    provisioned with an anonymous keypair that is not bound to a node,
    allowing access only to the unauthenticated endpoints
    `Scheduler.GetChallenge`, `Scheduler.Register` and
    `Scheduler.Recover`. This allows them to register or recover a
    node, but doesn't give access to the node itself. Upon registering
    or recovering an account the user receives a keypair that is bound
    to the specific node. Once the user receives their personal mTLS
    keypair they may use it to connect to greenlight, and thus get
    access to the node-specific functionality. Please refer to the
    documentation of your grpc library to learn how to configure grpc
    to use the node-specific mTLS keypair.

    """

    def Register(self, request, context):
        """A user may register a new node with greenlight by providing
        some basic metadata and proving that they have access to
        the corresponding private key (see challenge-response
        mechanism below). This means that in order to register a
        new node the user must have access to the corresponding
        private keys to prove ownership, and prevent users from
        just registering arbitrary node_ids without actually
        knowing the corresponding secrets.

        Upon successful registration an mTLS certificate and
        private key are returned. These can be used to authenticate
        future connections to the scheduler or the node.

        Each node may be registered once, any later attempt will
        result in an error being returned. If the user lost its
        credentials it can make use of the Recover RPC method to
        recover the credentials. Notice that this also means that
        the same node_id cannot be reused for different networks.
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def Recover(self, request, context):
        """Should a user have lost its credentials (mTLS keypair) for
        any reason, they may regain access to their node using the
        Recover RPC method. Similar to the initial registration the
        caller needs to authenticate the call by proving access to
        the node's secret. This also uses the challenge-response
        mechanism.

        Upon success a newly generated mTLS certificate and private
        key are returned, allowing the user to authenticate going
        forward. Existing keypairs are not revoked, in order to
        avoid locking out other authenticated applications.
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def GetChallenge(self, request, context):
        """Challenges are one-time values issued by the server, used
        to authenticate a user/device against the server. A user or
        device can authenticate to the server by signing the
        challenge and returning the signed message as part of the
        request that is to be authenticated.

        Challenges may not be reused, and are bound to the scope
        they have been issued for. Attempting to reuse a challenge
        or use a challenge with a different scope will result in an
        error being returned.
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def Schedule(self, request, context):
        """Scheduling takes a previously registered node, locates a
        free slot in greenlight's infrastructure and allocates it
        to run the node. The node then goes through the startup
        sequence, synchronizing with the blockchain, and finally
        binding its grpc interface (see Node service below) to a
        public IP address and port. Access is authenticated via the
        mTLS keypair the user received from registering or
        recovering the node.

        Upon success a NodeInfoResponse containing the grpc
        connection details and some metadata is returned. The
        application must use the grpc details and its node-specific
        mTLS keypair to interact with the node directly.
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def GetNodeInfo(self, request, context):
        """Much like `Schedule` this call is used to retrieve the
        metadata and grpc details of a node. Unlike the other call
        however it is passive, and will not result in the node
        being scheduled if it isn't already running. This can be
        used to check if a node is already scheduled, or to wait
        for it to be scheduled (e.g., if the caller is an `hsmd`
        that signs off on changes, but doesn't want to keep the
        node itself scheduled).
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def MaybeUpgrade(self, request, context):
        """The signer may want to trigger an upgrade of the node
        before waiting for the node to be scheduled. This ensures
        that the signer version is in sync with the node
        version. The scheduler may decide to defer upgrading if the
        protocols are compatible. Please do not use this directly,
        rather use the Signer in the client library to trigger this
        automatically when required. Posting an incomplete or
        non-functional UpgradeRequest may result in unschedulable
        nodes.
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def ListInviteCodes(self, request, context):
        """This call is used to fetch a list of invite codes associated
        with the node id of the client. These invite codes can be used
        for further registration of new nodes.
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def ExportNode(self, request, context):
        """Exporting a node allows users to take control of their node

        This method initiates the node export on Greenlight,
        allowing users to offboard from GL into their own
        infrastructure. After calling this method the node will no
        longer be schedulable on Greenlight, since it is never safe
        to assume there haven't been changes in the node's state
        (see CLN Backups documentation for details). `ExportNode`
        marks the node as `Exporting`, then generates an encryption
        secret which is then used to encrypt a database
        backup. This encrypted database backup is then made
        accessible through an HTTP server, and a link to it is
        returned as a response to `ExportNode`. After the export
        completes the node is marked as `Exported`. The encryption
        key can then be derived using the signer, using ECDH,
        allowing only users with the node secret to decrypt it.

        `ExportNode` is idempotent and may be called multiple
        times, without causing the node to be re-exported multiple
        times, should the call or the download be interrupted. DO
        NOT import the backup multiple times into your
        infrastructure, as that can lead to dataloss (old state
        being replayed) and loss of funds (see CLN Backups
        documentation for more information)
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def AddOutgoingWebhook(self, request, context):
        """Missing associated documentation comment in .proto file."""
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def ListOutgoingWebhooks(self, request, context):
        """Missing associated documentation comment in .proto file."""
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def DeleteWebhooks(self, request, context):
        """Missing associated documentation comment in .proto file."""
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def RotateOutgoingWebhookSecret(self, request, context):
        """Missing associated documentation comment in .proto file."""
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def SignerRequestsStream(self, request_iterator, context):
        """Attaches a Signer  via a bidirectional stream to the scheduler. 
        This is a communication channel between greenlight and the signing
        device that is used for requests that are not part of the node api.

        The stream is used to hand out the ApprovePairingRequests that
        the signer answers with a ApprovePairingResponse.
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')


def add_SchedulerServicer_to_server(servicer, server):
    rpc_method_handlers = {
            'Register': grpc.unary_unary_rpc_method_handler(
                    servicer.Register,
                    request_deserializer=glclient_dot_scheduler__pb2.RegistrationRequest.FromString,
                    response_serializer=glclient_dot_scheduler__pb2.RegistrationResponse.SerializeToString,
            ),
            'Recover': grpc.unary_unary_rpc_method_handler(
                    servicer.Recover,
                    request_deserializer=glclient_dot_scheduler__pb2.RecoveryRequest.FromString,
                    response_serializer=glclient_dot_scheduler__pb2.RecoveryResponse.SerializeToString,
            ),
            'GetChallenge': grpc.unary_unary_rpc_method_handler(
                    servicer.GetChallenge,
                    request_deserializer=glclient_dot_scheduler__pb2.ChallengeRequest.FromString,
                    response_serializer=glclient_dot_scheduler__pb2.ChallengeResponse.SerializeToString,
            ),
            'Schedule': grpc.unary_unary_rpc_method_handler(
                    servicer.Schedule,
                    request_deserializer=glclient_dot_scheduler__pb2.ScheduleRequest.FromString,
                    response_serializer=glclient_dot_scheduler__pb2.NodeInfoResponse.SerializeToString,
            ),
            'GetNodeInfo': grpc.unary_unary_rpc_method_handler(
                    servicer.GetNodeInfo,
                    request_deserializer=glclient_dot_scheduler__pb2.NodeInfoRequest.FromString,
                    response_serializer=glclient_dot_scheduler__pb2.NodeInfoResponse.SerializeToString,
            ),
            'MaybeUpgrade': grpc.unary_unary_rpc_method_handler(
                    servicer.MaybeUpgrade,
                    request_deserializer=glclient_dot_scheduler__pb2.UpgradeRequest.FromString,
                    response_serializer=glclient_dot_scheduler__pb2.UpgradeResponse.SerializeToString,
            ),
            'ListInviteCodes': grpc.unary_unary_rpc_method_handler(
                    servicer.ListInviteCodes,
                    request_deserializer=glclient_dot_scheduler__pb2.ListInviteCodesRequest.FromString,
                    response_serializer=glclient_dot_scheduler__pb2.ListInviteCodesResponse.SerializeToString,
            ),
            'ExportNode': grpc.unary_unary_rpc_method_handler(
                    servicer.ExportNode,
                    request_deserializer=glclient_dot_scheduler__pb2.ExportNodeRequest.FromString,
                    response_serializer=glclient_dot_scheduler__pb2.ExportNodeResponse.SerializeToString,
            ),
            'AddOutgoingWebhook': grpc.unary_unary_rpc_method_handler(
                    servicer.AddOutgoingWebhook,
                    request_deserializer=glclient_dot_scheduler__pb2.AddOutgoingWebhookRequest.FromString,
                    response_serializer=glclient_dot_scheduler__pb2.AddOutgoingWebhookResponse.SerializeToString,
            ),
            'ListOutgoingWebhooks': grpc.unary_unary_rpc_method_handler(
                    servicer.ListOutgoingWebhooks,
                    request_deserializer=glclient_dot_scheduler__pb2.ListOutgoingWebhooksRequest.FromString,
                    response_serializer=glclient_dot_scheduler__pb2.ListOutgoingWebhooksResponse.SerializeToString,
            ),
            'DeleteWebhooks': grpc.unary_unary_rpc_method_handler(
                    servicer.DeleteWebhooks,
                    request_deserializer=glclient_dot_scheduler__pb2.DeleteOutgoingWebhooksRequest.FromString,
                    response_serializer=glclient_dot_greenlight__pb2.Empty.SerializeToString,
            ),
            'RotateOutgoingWebhookSecret': grpc.unary_unary_rpc_method_handler(
                    servicer.RotateOutgoingWebhookSecret,
                    request_deserializer=glclient_dot_scheduler__pb2.RotateOutgoingWebhookSecretRequest.FromString,
                    response_serializer=glclient_dot_scheduler__pb2.WebhookSecretResponse.SerializeToString,
            ),
            'SignerRequestsStream': grpc.stream_stream_rpc_method_handler(
                    servicer.SignerRequestsStream,
                    request_deserializer=glclient_dot_scheduler__pb2.SignerResponse.FromString,
                    response_serializer=glclient_dot_scheduler__pb2.SignerRequest.SerializeToString,
            ),
    }
    generic_handler = grpc.method_handlers_generic_handler(
            'scheduler.Scheduler', rpc_method_handlers)
    server.add_generic_rpc_handlers((generic_handler,))
    server.add_registered_method_handlers('scheduler.Scheduler', rpc_method_handlers)


 # This class is part of an EXPERIMENTAL API.
class Scheduler(object):
    """The scheduler service is the endpoint which allows users to
    register a new node with greenlight, recover access to an existing
    node if the owner lost its credentials, schedule the node to be run
    on greenlight's infrastructure, and retrieve metadata about the
    node.

    Node
    ====

    A node is the basic object representing an account on
    greenlight. Each node corresponds to a c-lightning instance bound
    to a specific network that can be scheduled on greenlight, and must
    have a unique `node_id`.

    Nodes are scheduled on-demand onto the infrastructure, but the time
    to schedule a node is almost instantaneous.

    Authentication
    ==============

    Users are authenticated using mTLS authentication. Applications are
    provisioned with an anonymous keypair that is not bound to a node,
    allowing access only to the unauthenticated endpoints
    `Scheduler.GetChallenge`, `Scheduler.Register` and
    `Scheduler.Recover`. This allows them to register or recover a
    node, but doesn't give access to the node itself. Upon registering
    or recovering an account the user receives a keypair that is bound
    to the specific node. Once the user receives their personal mTLS
    keypair they may use it to connect to greenlight, and thus get
    access to the node-specific functionality. Please refer to the
    documentation of your grpc library to learn how to configure grpc
    to use the node-specific mTLS keypair.

    """

    @staticmethod
    def Register(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(
            request,
            target,
            '/scheduler.Scheduler/Register',
            glclient_dot_scheduler__pb2.RegistrationRequest.SerializeToString,
            glclient_dot_scheduler__pb2.RegistrationResponse.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)

    @staticmethod
    def Recover(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(
            request,
            target,
            '/scheduler.Scheduler/Recover',
            glclient_dot_scheduler__pb2.RecoveryRequest.SerializeToString,
            glclient_dot_scheduler__pb2.RecoveryResponse.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)

    @staticmethod
    def GetChallenge(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(
            request,
            target,
            '/scheduler.Scheduler/GetChallenge',
            glclient_dot_scheduler__pb2.ChallengeRequest.SerializeToString,
            glclient_dot_scheduler__pb2.ChallengeResponse.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)

    @staticmethod
    def Schedule(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(
            request,
            target,
            '/scheduler.Scheduler/Schedule',
            glclient_dot_scheduler__pb2.ScheduleRequest.SerializeToString,
            glclient_dot_scheduler__pb2.NodeInfoResponse.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)

    @staticmethod
    def GetNodeInfo(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(
            request,
            target,
            '/scheduler.Scheduler/GetNodeInfo',
            glclient_dot_scheduler__pb2.NodeInfoRequest.SerializeToString,
            glclient_dot_scheduler__pb2.NodeInfoResponse.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)

    @staticmethod
    def MaybeUpgrade(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(
            request,
            target,
            '/scheduler.Scheduler/MaybeUpgrade',
            glclient_dot_scheduler__pb2.UpgradeRequest.SerializeToString,
            glclient_dot_scheduler__pb2.UpgradeResponse.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)

    @staticmethod
    def ListInviteCodes(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(
            request,
            target,
            '/scheduler.Scheduler/ListInviteCodes',
            glclient_dot_scheduler__pb2.ListInviteCodesRequest.SerializeToString,
            glclient_dot_scheduler__pb2.ListInviteCodesResponse.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)

    @staticmethod
    def ExportNode(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(
            request,
            target,
            '/scheduler.Scheduler/ExportNode',
            glclient_dot_scheduler__pb2.ExportNodeRequest.SerializeToString,
            glclient_dot_scheduler__pb2.ExportNodeResponse.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)

    @staticmethod
    def AddOutgoingWebhook(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(
            request,
            target,
            '/scheduler.Scheduler/AddOutgoingWebhook',
            glclient_dot_scheduler__pb2.AddOutgoingWebhookRequest.SerializeToString,
            glclient_dot_scheduler__pb2.AddOutgoingWebhookResponse.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)

    @staticmethod
    def ListOutgoingWebhooks(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(
            request,
            target,
            '/scheduler.Scheduler/ListOutgoingWebhooks',
            glclient_dot_scheduler__pb2.ListOutgoingWebhooksRequest.SerializeToString,
            glclient_dot_scheduler__pb2.ListOutgoingWebhooksResponse.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)

    @staticmethod
    def DeleteWebhooks(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(
            request,
            target,
            '/scheduler.Scheduler/DeleteWebhooks',
            glclient_dot_scheduler__pb2.DeleteOutgoingWebhooksRequest.SerializeToString,
            glclient_dot_greenlight__pb2.Empty.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)

    @staticmethod
    def RotateOutgoingWebhookSecret(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(
            request,
            target,
            '/scheduler.Scheduler/RotateOutgoingWebhookSecret',
            glclient_dot_scheduler__pb2.RotateOutgoingWebhookSecretRequest.SerializeToString,
            glclient_dot_scheduler__pb2.WebhookSecretResponse.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)

    @staticmethod
    def SignerRequestsStream(request_iterator,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.stream_stream(
            request_iterator,
            target,
            '/scheduler.Scheduler/SignerRequestsStream',
            glclient_dot_scheduler__pb2.SignerResponse.SerializeToString,
            glclient_dot_scheduler__pb2.SignerRequest.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)


class DebugStub(object):
    """A service to collect debugging information from clients.
    """

    def __init__(self, channel):
        """Constructor.

        Args:
            channel: A grpc.Channel.
        """
        self.ReportSignerRejection = channel.unary_unary(
                '/scheduler.Debug/ReportSignerRejection',
                request_serializer=glclient_dot_scheduler__pb2.SignerRejection.SerializeToString,
                response_deserializer=glclient_dot_greenlight__pb2.Empty.FromString,
                _registered_method=True)


class DebugServicer(object):
    """A service to collect debugging information from clients.
    """

    def ReportSignerRejection(self, request, context):
        """The signer is designed to fail closed, i.e., we reject requests
        that do not resolve or that go against one of its policies. This
        comes with some issues, such as false negatives, where we reject
        despite the request being valid. As more apps use the API we need
        to debug these false negatives, hence why we report rejections,
        so we can investigate the validity of the rejection, and to
        fine-tine the signer's ruleset.
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')


def add_DebugServicer_to_server(servicer, server):
    rpc_method_handlers = {
            'ReportSignerRejection': grpc.unary_unary_rpc_method_handler(
                    servicer.ReportSignerRejection,
                    request_deserializer=glclient_dot_scheduler__pb2.SignerRejection.FromString,
                    response_serializer=glclient_dot_greenlight__pb2.Empty.SerializeToString,
            ),
    }
    generic_handler = grpc.method_handlers_generic_handler(
            'scheduler.Debug', rpc_method_handlers)
    server.add_generic_rpc_handlers((generic_handler,))
    server.add_registered_method_handlers('scheduler.Debug', rpc_method_handlers)


 # This class is part of an EXPERIMENTAL API.
class Debug(object):
    """A service to collect debugging information from clients.
    """

    @staticmethod
    def ReportSignerRejection(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(
            request,
            target,
            '/scheduler.Debug/ReportSignerRejection',
            glclient_dot_scheduler__pb2.SignerRejection.SerializeToString,
            glclient_dot_greenlight__pb2.Empty.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)


class PairingStub(object):
    """A service to pair signer-less clients with an existing signer.
    """

    def __init__(self, channel):
        """Constructor.

        Args:
            channel: A grpc.Channel.
        """
        self.PairDevice = channel.unary_unary(
                '/scheduler.Pairing/PairDevice',
                request_serializer=glclient_dot_scheduler__pb2.PairDeviceRequest.SerializeToString,
                response_deserializer=glclient_dot_scheduler__pb2.PairDeviceResponse.FromString,
                _registered_method=True)
        self.GetPairingData = channel.unary_unary(
                '/scheduler.Pairing/GetPairingData',
                request_serializer=glclient_dot_scheduler__pb2.GetPairingDataRequest.SerializeToString,
                response_deserializer=glclient_dot_scheduler__pb2.GetPairingDataResponse.FromString,
                _registered_method=True)
        self.ApprovePairing = channel.unary_unary(
                '/scheduler.Pairing/ApprovePairing',
                request_serializer=glclient_dot_scheduler__pb2.ApprovePairingRequest.SerializeToString,
                response_deserializer=glclient_dot_greenlight__pb2.Empty.FromString,
                _registered_method=True)


class PairingServicer(object):
    """A service to pair signer-less clients with an existing signer.
    """

    def PairDevice(self, request, context):
        """Initiates a new Pairing Sessions. This is called by the new
        device that wants to request a pairing from an existing device.
        The session lifetime is bound to the stream so closing the
        stream destroys the session.
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def GetPairingData(self, request, context):
        """Returns the pairing related data that belongs to a pairing
        session. This is meant to be called from a device that can
        approve a pairing request, we sometimes call it "old device".
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def ApprovePairing(self, request, context):
        """Approves a pairing request. The ApprovePairingRequest is
        forwarded to a signer for further processing.
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')


def add_PairingServicer_to_server(servicer, server):
    rpc_method_handlers = {
            'PairDevice': grpc.unary_unary_rpc_method_handler(
                    servicer.PairDevice,
                    request_deserializer=glclient_dot_scheduler__pb2.PairDeviceRequest.FromString,
                    response_serializer=glclient_dot_scheduler__pb2.PairDeviceResponse.SerializeToString,
            ),
            'GetPairingData': grpc.unary_unary_rpc_method_handler(
                    servicer.GetPairingData,
                    request_deserializer=glclient_dot_scheduler__pb2.GetPairingDataRequest.FromString,
                    response_serializer=glclient_dot_scheduler__pb2.GetPairingDataResponse.SerializeToString,
            ),
            'ApprovePairing': grpc.unary_unary_rpc_method_handler(
                    servicer.ApprovePairing,
                    request_deserializer=glclient_dot_scheduler__pb2.ApprovePairingRequest.FromString,
                    response_serializer=glclient_dot_greenlight__pb2.Empty.SerializeToString,
            ),
    }
    generic_handler = grpc.method_handlers_generic_handler(
            'scheduler.Pairing', rpc_method_handlers)
    server.add_generic_rpc_handlers((generic_handler,))
    server.add_registered_method_handlers('scheduler.Pairing', rpc_method_handlers)


 # This class is part of an EXPERIMENTAL API.
class Pairing(object):
    """A service to pair signer-less clients with an existing signer.
    """

    @staticmethod
    def PairDevice(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(
            request,
            target,
            '/scheduler.Pairing/PairDevice',
            glclient_dot_scheduler__pb2.PairDeviceRequest.SerializeToString,
            glclient_dot_scheduler__pb2.PairDeviceResponse.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)

    @staticmethod
    def GetPairingData(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(
            request,
            target,
            '/scheduler.Pairing/GetPairingData',
            glclient_dot_scheduler__pb2.GetPairingDataRequest.SerializeToString,
            glclient_dot_scheduler__pb2.GetPairingDataResponse.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)

    @staticmethod
    def ApprovePairing(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(
            request,
            target,
            '/scheduler.Pairing/ApprovePairing',
            glclient_dot_scheduler__pb2.ApprovePairingRequest.SerializeToString,
            glclient_dot_greenlight__pb2.Empty.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)
