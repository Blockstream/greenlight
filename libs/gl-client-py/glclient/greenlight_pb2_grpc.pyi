"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
"""

from collections import abc as _abc
from glclient import greenlight_pb2 as _greenlight_pb2
from grpc import aio as _aio
import abc as _abc_1
import grpc as _grpc
import sys
import typing as _typing

if sys.version_info >= (3, 11):
    from typing import Self as _Self
else:
    from typing_extensions import Self as _Self

_T = _typing.TypeVar("_T")

class _MaybeAsyncIterator(_abc.AsyncIterator[_T], _abc.Iterator[_T], metaclass=_abc_1.ABCMeta): ...

class _ServicerContext(_grpc.ServicerContext, _aio.ServicerContext):  # type: ignore[misc, type-arg]
    ...

GRPC_GENERATED_VERSION: str
GRPC_VERSION: str

class NodeStub:
    """The node service represents your node running on greenlight's
    infrastructure. You can use the exposed RPC methods to interact
    with your node. The URI used to connect to the node depends on
    where the node is being scheduled and is returned by the
    `Scheduler.Schedule()` RPC call.

    Notice that in order to connect to the node the caller must use the
    node-specific mTLS keypair returned by `Scheduler.Register()` or
    `Scheduler.Recover()`. In particular the anonymous mTLS keypair is
    rejected by the node.

    Deprecated methods are being replaced by the standardized and
    automatically managed cln-grpc protocol you can find in
    `node.proto`. This interface consists mostly of
    Greenlight-specific, and backported functionality.
    """

    @_typing.overload
    def __new__(cls, channel: _grpc.Channel) -> _Self: ...
    @_typing.overload
    def __new__(cls, channel: _aio.Channel) -> NodeAsyncStub: ...
    LspInvoice: _grpc.UnaryUnaryMultiCallable[_greenlight_pb2.LspInvoiceRequest, _greenlight_pb2.LspInvoiceResponse]
    """Create an invoice to request an incoming payment. Includes LSP
    negotiation to open a channel on-demand when needed.
    """
    StreamLog: _grpc.UnaryStreamMultiCallable[_greenlight_pb2.StreamLogRequest, _greenlight_pb2.LogEntry]
    """Stream incoming payments

    Currently includes off-chain payments received matching an
    invoice or spontaneus paymens through keysend.

    Stream the logs as they are produced by the node

    Mainly intended for debugging clients by tailing the log as
    they are written on the node. The logs start streaming from
    the first beginning, in order to allow inspection of events
    after an error occurred, That also means that the logs can
    be rather large, and should not be streamed onto
    resource-constrained devices.
    """
    StreamCustommsg: _grpc.UnaryStreamMultiCallable[_greenlight_pb2.StreamCustommsgRequest, _greenlight_pb2.Custommsg]
    """Listen for incoming `custommsg` messages from peers.

    The messages are forwarded as they come in, and will not be
    replayed if the stream is interrupted.
    """
    StreamNodeEvents: _grpc.UnaryStreamMultiCallable[_greenlight_pb2.NodeEventsRequest, _greenlight_pb2.NodeEvent]
    """Stream node events in real-time.

    This is a unified event stream that delivers various node events
    as they occur, including invoice updates, peer changes, channel
    state changes, and balance updates. Events are not persisted and
    will not be replayed if the stream is interrupted.
    """
    StreamHsmRequests: _grpc.UnaryStreamMultiCallable[_greenlight_pb2.Empty, _greenlight_pb2.HsmRequest]
    """////////////////////////////// HSM Messages ////////////////////////

    The following messages are related to communicating HSM
    requests back and forth. Chances are you won't need to
    interact with these at all, unless you want to embed the
    hsmd into your client. We recommend using a standalone hsmd
    such as hagrid, keeper of keys, to get started.

    Stream requests from the node to any key device that can
    respond to them.
    """
    RespondHsmRequest: _grpc.UnaryUnaryMultiCallable[_greenlight_pb2.HsmResponse, _greenlight_pb2.Empty]
    Configure: _grpc.UnaryUnaryMultiCallable[_greenlight_pb2.GlConfig, _greenlight_pb2.Empty]
    TrampolinePay: _grpc.UnaryUnaryMultiCallable[_greenlight_pb2.TrampolinePayRequest, _greenlight_pb2.TrampolinePayResponse]

@_typing.type_check_only
class NodeAsyncStub(NodeStub):
    """The node service represents your node running on greenlight's
    infrastructure. You can use the exposed RPC methods to interact
    with your node. The URI used to connect to the node depends on
    where the node is being scheduled and is returned by the
    `Scheduler.Schedule()` RPC call.

    Notice that in order to connect to the node the caller must use the
    node-specific mTLS keypair returned by `Scheduler.Register()` or
    `Scheduler.Recover()`. In particular the anonymous mTLS keypair is
    rejected by the node.

    Deprecated methods are being replaced by the standardized and
    automatically managed cln-grpc protocol you can find in
    `node.proto`. This interface consists mostly of
    Greenlight-specific, and backported functionality.
    """

    def __init__(self, channel: _aio.Channel) -> None: ...
    LspInvoice: _aio.UnaryUnaryMultiCallable[_greenlight_pb2.LspInvoiceRequest, _greenlight_pb2.LspInvoiceResponse]  # type: ignore[assignment]
    """Create an invoice to request an incoming payment. Includes LSP
    negotiation to open a channel on-demand when needed.
    """
    StreamLog: _aio.UnaryStreamMultiCallable[_greenlight_pb2.StreamLogRequest, _greenlight_pb2.LogEntry]  # type: ignore[assignment]
    """Stream incoming payments

    Currently includes off-chain payments received matching an
    invoice or spontaneus paymens through keysend.

    Stream the logs as they are produced by the node

    Mainly intended for debugging clients by tailing the log as
    they are written on the node. The logs start streaming from
    the first beginning, in order to allow inspection of events
    after an error occurred, That also means that the logs can
    be rather large, and should not be streamed onto
    resource-constrained devices.
    """
    StreamCustommsg: _aio.UnaryStreamMultiCallable[_greenlight_pb2.StreamCustommsgRequest, _greenlight_pb2.Custommsg]  # type: ignore[assignment]
    """Listen for incoming `custommsg` messages from peers.

    The messages are forwarded as they come in, and will not be
    replayed if the stream is interrupted.
    """
    StreamNodeEvents: _aio.UnaryStreamMultiCallable[_greenlight_pb2.NodeEventsRequest, _greenlight_pb2.NodeEvent]  # type: ignore[assignment]
    """Stream node events in real-time.

    This is a unified event stream that delivers various node events
    as they occur, including invoice updates, peer changes, channel
    state changes, and balance updates. Events are not persisted and
    will not be replayed if the stream is interrupted.
    """
    StreamHsmRequests: _aio.UnaryStreamMultiCallable[_greenlight_pb2.Empty, _greenlight_pb2.HsmRequest]  # type: ignore[assignment]
    """////////////////////////////// HSM Messages ////////////////////////

    The following messages are related to communicating HSM
    requests back and forth. Chances are you won't need to
    interact with these at all, unless you want to embed the
    hsmd into your client. We recommend using a standalone hsmd
    such as hagrid, keeper of keys, to get started.

    Stream requests from the node to any key device that can
    respond to them.
    """
    RespondHsmRequest: _aio.UnaryUnaryMultiCallable[_greenlight_pb2.HsmResponse, _greenlight_pb2.Empty]  # type: ignore[assignment]
    Configure: _aio.UnaryUnaryMultiCallable[_greenlight_pb2.GlConfig, _greenlight_pb2.Empty]  # type: ignore[assignment]
    TrampolinePay: _aio.UnaryUnaryMultiCallable[_greenlight_pb2.TrampolinePayRequest, _greenlight_pb2.TrampolinePayResponse]  # type: ignore[assignment]

class NodeServicer(metaclass=_abc_1.ABCMeta):
    """The node service represents your node running on greenlight's
    infrastructure. You can use the exposed RPC methods to interact
    with your node. The URI used to connect to the node depends on
    where the node is being scheduled and is returned by the
    `Scheduler.Schedule()` RPC call.

    Notice that in order to connect to the node the caller must use the
    node-specific mTLS keypair returned by `Scheduler.Register()` or
    `Scheduler.Recover()`. In particular the anonymous mTLS keypair is
    rejected by the node.

    Deprecated methods are being replaced by the standardized and
    automatically managed cln-grpc protocol you can find in
    `node.proto`. This interface consists mostly of
    Greenlight-specific, and backported functionality.
    """

    @_abc_1.abstractmethod
    def LspInvoice(
        self,
        request: _greenlight_pb2.LspInvoiceRequest,
        context: _ServicerContext,
    ) -> _typing.Union[_greenlight_pb2.LspInvoiceResponse, _abc.Awaitable[_greenlight_pb2.LspInvoiceResponse]]:
        """Create an invoice to request an incoming payment. Includes LSP
        negotiation to open a channel on-demand when needed.
        """

    @_abc_1.abstractmethod
    def StreamLog(
        self,
        request: _greenlight_pb2.StreamLogRequest,
        context: _ServicerContext,
    ) -> _typing.Union[_abc.Iterator[_greenlight_pb2.LogEntry], _abc.AsyncIterator[_greenlight_pb2.LogEntry]]:
        """Stream incoming payments

        Currently includes off-chain payments received matching an
        invoice or spontaneus paymens through keysend.

        Stream the logs as they are produced by the node

        Mainly intended for debugging clients by tailing the log as
        they are written on the node. The logs start streaming from
        the first beginning, in order to allow inspection of events
        after an error occurred, That also means that the logs can
        be rather large, and should not be streamed onto
        resource-constrained devices.
        """

    @_abc_1.abstractmethod
    def StreamCustommsg(
        self,
        request: _greenlight_pb2.StreamCustommsgRequest,
        context: _ServicerContext,
    ) -> _typing.Union[_abc.Iterator[_greenlight_pb2.Custommsg], _abc.AsyncIterator[_greenlight_pb2.Custommsg]]:
        """Listen for incoming `custommsg` messages from peers.

        The messages are forwarded as they come in, and will not be
        replayed if the stream is interrupted.
        """

    @_abc_1.abstractmethod
    def StreamNodeEvents(
        self,
        request: _greenlight_pb2.NodeEventsRequest,
        context: _ServicerContext,
    ) -> _typing.Union[_abc.Iterator[_greenlight_pb2.NodeEvent], _abc.AsyncIterator[_greenlight_pb2.NodeEvent]]:
        """Stream node events in real-time.

        This is a unified event stream that delivers various node events
        as they occur, including invoice updates, peer changes, channel
        state changes, and balance updates. Events are not persisted and
        will not be replayed if the stream is interrupted.
        """

    @_abc_1.abstractmethod
    def StreamHsmRequests(
        self,
        request: _greenlight_pb2.Empty,
        context: _ServicerContext,
    ) -> _typing.Union[_abc.Iterator[_greenlight_pb2.HsmRequest], _abc.AsyncIterator[_greenlight_pb2.HsmRequest]]:
        """////////////////////////////// HSM Messages ////////////////////////

        The following messages are related to communicating HSM
        requests back and forth. Chances are you won't need to
        interact with these at all, unless you want to embed the
        hsmd into your client. We recommend using a standalone hsmd
        such as hagrid, keeper of keys, to get started.

        Stream requests from the node to any key device that can
        respond to them.
        """

    @_abc_1.abstractmethod
    def RespondHsmRequest(
        self,
        request: _greenlight_pb2.HsmResponse,
        context: _ServicerContext,
    ) -> _typing.Union[_greenlight_pb2.Empty, _abc.Awaitable[_greenlight_pb2.Empty]]: ...

    @_abc_1.abstractmethod
    def Configure(
        self,
        request: _greenlight_pb2.GlConfig,
        context: _ServicerContext,
    ) -> _typing.Union[_greenlight_pb2.Empty, _abc.Awaitable[_greenlight_pb2.Empty]]: ...

    @_abc_1.abstractmethod
    def TrampolinePay(
        self,
        request: _greenlight_pb2.TrampolinePayRequest,
        context: _ServicerContext,
    ) -> _typing.Union[_greenlight_pb2.TrampolinePayResponse, _abc.Awaitable[_greenlight_pb2.TrampolinePayResponse]]: ...

def add_NodeServicer_to_server(servicer: NodeServicer, server: _typing.Union[_grpc.Server, _aio.Server]) -> None: ...

class HsmStub:
    @_typing.overload
    def __new__(cls, channel: _grpc.Channel) -> _Self: ...
    @_typing.overload
    def __new__(cls, channel: _aio.Channel) -> HsmAsyncStub: ...
    Request: _grpc.UnaryUnaryMultiCallable[_greenlight_pb2.HsmRequest, _greenlight_pb2.HsmResponse]
    Ping: _grpc.UnaryUnaryMultiCallable[_greenlight_pb2.Empty, _greenlight_pb2.Empty]

@_typing.type_check_only
class HsmAsyncStub(HsmStub):
    def __init__(self, channel: _aio.Channel) -> None: ...
    Request: _aio.UnaryUnaryMultiCallable[_greenlight_pb2.HsmRequest, _greenlight_pb2.HsmResponse]  # type: ignore[assignment]
    Ping: _aio.UnaryUnaryMultiCallable[_greenlight_pb2.Empty, _greenlight_pb2.Empty]  # type: ignore[assignment]

class HsmServicer(metaclass=_abc_1.ABCMeta):
    @_abc_1.abstractmethod
    def Request(
        self,
        request: _greenlight_pb2.HsmRequest,
        context: _ServicerContext,
    ) -> _typing.Union[_greenlight_pb2.HsmResponse, _abc.Awaitable[_greenlight_pb2.HsmResponse]]: ...

    @_abc_1.abstractmethod
    def Ping(
        self,
        request: _greenlight_pb2.Empty,
        context: _ServicerContext,
    ) -> _typing.Union[_greenlight_pb2.Empty, _abc.Awaitable[_greenlight_pb2.Empty]]: ...

def add_HsmServicer_to_server(servicer: HsmServicer, server: _typing.Union[_grpc.Server, _aio.Server]) -> None: ...
