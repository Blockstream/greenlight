"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
"""

import abc
import collections.abc
import glclient.greenlight_pb2
import grpc
import grpc.aio
import typing

_T = typing.TypeVar("_T")

class _MaybeAsyncIterator(collections.abc.AsyncIterator[_T], collections.abc.Iterator[_T], metaclass=abc.ABCMeta): ...

class _ServicerContext(grpc.ServicerContext, grpc.aio.ServicerContext):  # type: ignore[misc, type-arg]
    ...

class NodeStub:
    """The node service represents your node running on greenlight's
    infrastructure. You can use the exposed RPC methods to interact
    with your node. The URI used to connect to the node depends on
    where the node is being scheduled and is returned by the
    `Scheduler.Schedule()` RPC call.

    Notice that in order to connect to the node the caller must use the
    node-specific mTLS keypair returned by `Scheduler.Register()` or
    `Scheduler.Recover()`. In particular the anonymous mTLS keypair is
    rejected by the node.

    Deprecated methods are being replaced by the standardized and
    automatically managed cln-grpc protocol you can find in
    `node.proto`
    """

    def __init__(self, channel: typing.Union[grpc.Channel, grpc.aio.Channel]) -> None: ...
    StreamIncoming: grpc.UnaryStreamMultiCallable[
        glclient.greenlight_pb2.StreamIncomingFilter,
        glclient.greenlight_pb2.IncomingPayment,
    ]
    """Stream incoming payments

    Currently includes off-chain payments received matching an
    invoice or spontaneus paymens through keysend.
    """

    StreamLog: grpc.UnaryStreamMultiCallable[
        glclient.greenlight_pb2.StreamLogRequest,
        glclient.greenlight_pb2.LogEntry,
    ]
    """Stream the logs as they are produced by the node

    Mainly intended for debugging clients by tailing the log as
    they are written on the node. The logs start streaming from
    the first beginning, in order to allow inspection of events
    after an error occurred, That also means that the logs can
    be rather large, and should not be streamed onto
    resource-constrained devices.
    """

    StreamCustommsg: grpc.UnaryStreamMultiCallable[
        glclient.greenlight_pb2.StreamCustommsgRequest,
        glclient.greenlight_pb2.Custommsg,
    ]
    """Listen for incoming `custommsg` messages from peers.

    The messages are forwarded as they come in, and will not be
    replayed if the stream is interrupted.
    """

    StreamHsmRequests: grpc.UnaryStreamMultiCallable[
        glclient.greenlight_pb2.Empty,
        glclient.greenlight_pb2.HsmRequest,
    ]
    """////////////////////////////// HSM Messages ////////////////////////

    The following messages are related to communicating HSM
    requests back and forth. Chances are you won't need to
    interact with these at all, unless you want to embed the
    hsmd into your client. We recommend using a standalone hsmd
    such as hagrid, keeper of keys, to get started.

    Stream requests from the node to any key device that can
    respond to them.
    """

    RespondHsmRequest: grpc.UnaryUnaryMultiCallable[
        glclient.greenlight_pb2.HsmResponse,
        glclient.greenlight_pb2.Empty,
    ]

    Configure: grpc.UnaryUnaryMultiCallable[
        glclient.greenlight_pb2.GlConfig,
        glclient.greenlight_pb2.Empty,
    ]

    TrampolinePay: grpc.UnaryUnaryMultiCallable[
        glclient.greenlight_pb2.TrampolinePayRequest,
        glclient.greenlight_pb2.TrampolinePayResponse,
    ]

class NodeAsyncStub:
    """The node service represents your node running on greenlight's
    infrastructure. You can use the exposed RPC methods to interact
    with your node. The URI used to connect to the node depends on
    where the node is being scheduled and is returned by the
    `Scheduler.Schedule()` RPC call.

    Notice that in order to connect to the node the caller must use the
    node-specific mTLS keypair returned by `Scheduler.Register()` or
    `Scheduler.Recover()`. In particular the anonymous mTLS keypair is
    rejected by the node.

    Deprecated methods are being replaced by the standardized and
    automatically managed cln-grpc protocol you can find in
    `node.proto`
    """

    StreamIncoming: grpc.aio.UnaryStreamMultiCallable[
        glclient.greenlight_pb2.StreamIncomingFilter,
        glclient.greenlight_pb2.IncomingPayment,
    ]
    """Stream incoming payments

    Currently includes off-chain payments received matching an
    invoice or spontaneus paymens through keysend.
    """

    StreamLog: grpc.aio.UnaryStreamMultiCallable[
        glclient.greenlight_pb2.StreamLogRequest,
        glclient.greenlight_pb2.LogEntry,
    ]
    """Stream the logs as they are produced by the node

    Mainly intended for debugging clients by tailing the log as
    they are written on the node. The logs start streaming from
    the first beginning, in order to allow inspection of events
    after an error occurred, That also means that the logs can
    be rather large, and should not be streamed onto
    resource-constrained devices.
    """

    StreamCustommsg: grpc.aio.UnaryStreamMultiCallable[
        glclient.greenlight_pb2.StreamCustommsgRequest,
        glclient.greenlight_pb2.Custommsg,
    ]
    """Listen for incoming `custommsg` messages from peers.

    The messages are forwarded as they come in, and will not be
    replayed if the stream is interrupted.
    """

    StreamHsmRequests: grpc.aio.UnaryStreamMultiCallable[
        glclient.greenlight_pb2.Empty,
        glclient.greenlight_pb2.HsmRequest,
    ]
    """////////////////////////////// HSM Messages ////////////////////////

    The following messages are related to communicating HSM
    requests back and forth. Chances are you won't need to
    interact with these at all, unless you want to embed the
    hsmd into your client. We recommend using a standalone hsmd
    such as hagrid, keeper of keys, to get started.

    Stream requests from the node to any key device that can
    respond to them.
    """

    RespondHsmRequest: grpc.aio.UnaryUnaryMultiCallable[
        glclient.greenlight_pb2.HsmResponse,
        glclient.greenlight_pb2.Empty,
    ]

    Configure: grpc.aio.UnaryUnaryMultiCallable[
        glclient.greenlight_pb2.GlConfig,
        glclient.greenlight_pb2.Empty,
    ]

    TrampolinePay: grpc.aio.UnaryUnaryMultiCallable[
        glclient.greenlight_pb2.TrampolinePayRequest,
        glclient.greenlight_pb2.TrampolinePayResponse,
    ]

class NodeServicer(metaclass=abc.ABCMeta):
    """The node service represents your node running on greenlight's
    infrastructure. You can use the exposed RPC methods to interact
    with your node. The URI used to connect to the node depends on
    where the node is being scheduled and is returned by the
    `Scheduler.Schedule()` RPC call.

    Notice that in order to connect to the node the caller must use the
    node-specific mTLS keypair returned by `Scheduler.Register()` or
    `Scheduler.Recover()`. In particular the anonymous mTLS keypair is
    rejected by the node.

    Deprecated methods are being replaced by the standardized and
    automatically managed cln-grpc protocol you can find in
    `node.proto`
    """

    @abc.abstractmethod
    def StreamIncoming(
        self,
        request: glclient.greenlight_pb2.StreamIncomingFilter,
        context: _ServicerContext,
    ) -> typing.Union[collections.abc.Iterator[glclient.greenlight_pb2.IncomingPayment], collections.abc.AsyncIterator[glclient.greenlight_pb2.IncomingPayment]]:
        """Stream incoming payments

        Currently includes off-chain payments received matching an
        invoice or spontaneus paymens through keysend.
        """

    @abc.abstractmethod
    def StreamLog(
        self,
        request: glclient.greenlight_pb2.StreamLogRequest,
        context: _ServicerContext,
    ) -> typing.Union[collections.abc.Iterator[glclient.greenlight_pb2.LogEntry], collections.abc.AsyncIterator[glclient.greenlight_pb2.LogEntry]]:
        """Stream the logs as they are produced by the node

        Mainly intended for debugging clients by tailing the log as
        they are written on the node. The logs start streaming from
        the first beginning, in order to allow inspection of events
        after an error occurred, That also means that the logs can
        be rather large, and should not be streamed onto
        resource-constrained devices.
        """

    @abc.abstractmethod
    def StreamCustommsg(
        self,
        request: glclient.greenlight_pb2.StreamCustommsgRequest,
        context: _ServicerContext,
    ) -> typing.Union[collections.abc.Iterator[glclient.greenlight_pb2.Custommsg], collections.abc.AsyncIterator[glclient.greenlight_pb2.Custommsg]]:
        """Listen for incoming `custommsg` messages from peers.

        The messages are forwarded as they come in, and will not be
        replayed if the stream is interrupted.
        """

    @abc.abstractmethod
    def StreamHsmRequests(
        self,
        request: glclient.greenlight_pb2.Empty,
        context: _ServicerContext,
    ) -> typing.Union[collections.abc.Iterator[glclient.greenlight_pb2.HsmRequest], collections.abc.AsyncIterator[glclient.greenlight_pb2.HsmRequest]]:
        """////////////////////////////// HSM Messages ////////////////////////

        The following messages are related to communicating HSM
        requests back and forth. Chances are you won't need to
        interact with these at all, unless you want to embed the
        hsmd into your client. We recommend using a standalone hsmd
        such as hagrid, keeper of keys, to get started.

        Stream requests from the node to any key device that can
        respond to them.
        """

    @abc.abstractmethod
    def RespondHsmRequest(
        self,
        request: glclient.greenlight_pb2.HsmResponse,
        context: _ServicerContext,
    ) -> typing.Union[glclient.greenlight_pb2.Empty, collections.abc.Awaitable[glclient.greenlight_pb2.Empty]]: ...

    @abc.abstractmethod
    def Configure(
        self,
        request: glclient.greenlight_pb2.GlConfig,
        context: _ServicerContext,
    ) -> typing.Union[glclient.greenlight_pb2.Empty, collections.abc.Awaitable[glclient.greenlight_pb2.Empty]]: ...

    @abc.abstractmethod
    def TrampolinePay(
        self,
        request: glclient.greenlight_pb2.TrampolinePayRequest,
        context: _ServicerContext,
    ) -> typing.Union[glclient.greenlight_pb2.TrampolinePayResponse, collections.abc.Awaitable[glclient.greenlight_pb2.TrampolinePayResponse]]: ...

def add_NodeServicer_to_server(servicer: NodeServicer, server: typing.Union[grpc.Server, grpc.aio.Server]) -> None: ...

class HsmStub:
    def __init__(self, channel: typing.Union[grpc.Channel, grpc.aio.Channel]) -> None: ...
    Request: grpc.UnaryUnaryMultiCallable[
        glclient.greenlight_pb2.HsmRequest,
        glclient.greenlight_pb2.HsmResponse,
    ]

    Ping: grpc.UnaryUnaryMultiCallable[
        glclient.greenlight_pb2.Empty,
        glclient.greenlight_pb2.Empty,
    ]

class HsmAsyncStub:
    Request: grpc.aio.UnaryUnaryMultiCallable[
        glclient.greenlight_pb2.HsmRequest,
        glclient.greenlight_pb2.HsmResponse,
    ]

    Ping: grpc.aio.UnaryUnaryMultiCallable[
        glclient.greenlight_pb2.Empty,
        glclient.greenlight_pb2.Empty,
    ]

class HsmServicer(metaclass=abc.ABCMeta):
    @abc.abstractmethod
    def Request(
        self,
        request: glclient.greenlight_pb2.HsmRequest,
        context: _ServicerContext,
    ) -> typing.Union[glclient.greenlight_pb2.HsmResponse, collections.abc.Awaitable[glclient.greenlight_pb2.HsmResponse]]: ...

    @abc.abstractmethod
    def Ping(
        self,
        request: glclient.greenlight_pb2.Empty,
        context: _ServicerContext,
    ) -> typing.Union[glclient.greenlight_pb2.Empty, collections.abc.Awaitable[glclient.greenlight_pb2.Empty]]: ...

def add_HsmServicer_to_server(servicer: HsmServicer, server: typing.Union[grpc.Server, grpc.aio.Server]) -> None: ...
