// This file was autogenerated by some hot garbage in the `uniffi` crate.
// Trust me, you don't want to mess with it!


// Unit struct to parameterize the FfiConverter trait.
//
// We use FfiConverter<UniFfiTag> to handle lowering/lifting/serializing types for this crate.  See
// https://mozilla.github.io/uniffi-rs/internals/lifting_and_lowering.html#code-generation-and-the-fficonverter-trait
// for details.
//
// This is pub, since we need to access it to support external types
#[doc(hidden)]
pub struct UniFfiTag;

#[allow(clippy::missing_safety_doc, missing_docs)]
#[doc(hidden)]
#[no_mangle]
pub extern "C" fn ffi_glclient_uniffi_contract_version() -> u32 {
    22
}
/// Export namespace metadata.
///
/// See `uniffi_bindgen::macro_metadata` for how this is used.

const UNIFFI_META_CONST_NAMESPACE_GLCLIENT: ::uniffi::MetadataBuffer = ::uniffi::MetadataBuffer::from_code(::uniffi::metadata::codes::NAMESPACE)
    .concat_str(env!("CARGO_CRATE_NAME"))
    .concat_str("glclient");

#[doc(hidden)]
#[no_mangle]
pub static UNIFFI_META_NAMESPACE_GLCLIENT: [u8; UNIFFI_META_CONST_NAMESPACE_GLCLIENT.size] = UNIFFI_META_CONST_NAMESPACE_GLCLIENT.into_array();

// Check for compatibility between `uniffi` and `uniffi_bindgen` versions.
// Note that we have an error message on the same line as the assertion.
// This is important, because if the assertion fails, the compiler only
// seems to show that single line as context for the user.
uniffi::assert_compatible_version!("0.24.3"); // Please check that you depend on version 0.24.3 of the `uniffi` crate.








// Everybody gets basic buffer support, since it's needed for passing complex types over the FFI.
//
// See `uniffi/src/ffi/rustbuffer.rs` for documentation on these functions

#[allow(clippy::missing_safety_doc, missing_docs)]
#[doc(hidden)]
#[no_mangle]
pub extern "C" fn ffi_glclient_rustbuffer_alloc(size: i32, call_status: &mut uniffi::RustCallStatus) -> uniffi::RustBuffer {
    uniffi::ffi::uniffi_rustbuffer_alloc(size, call_status)
}

#[allow(clippy::missing_safety_doc, missing_docs)]
#[doc(hidden)]
#[no_mangle]
pub unsafe extern "C" fn ffi_glclient_rustbuffer_from_bytes(bytes: uniffi::ForeignBytes, call_status: &mut uniffi::RustCallStatus) -> uniffi::RustBuffer {
    uniffi::ffi::uniffi_rustbuffer_from_bytes(bytes, call_status)
}

#[allow(clippy::missing_safety_doc, missing_docs)]
#[doc(hidden)]
#[no_mangle]
pub unsafe extern "C" fn ffi_glclient_rustbuffer_free(buf: uniffi::RustBuffer, call_status: &mut uniffi::RustCallStatus) {
    uniffi::ffi::uniffi_rustbuffer_free(buf, call_status);
}

#[allow(clippy::missing_safety_doc, missing_docs)]
#[doc(hidden)]
#[no_mangle]
pub unsafe extern "C" fn ffi_glclient_rustbuffer_reserve(buf: uniffi::RustBuffer, additional: i32, call_status: &mut uniffi::RustCallStatus) -> uniffi::RustBuffer {
    uniffi::ffi::uniffi_rustbuffer_reserve(buf, additional, call_status)
}



// Error definitions, corresponding to `error` in the UDL.


#[::uniffi::ffi_converter_error(
    tag = crate::UniFfiTag,
    flat_error,
    
)]
enum r#Error {
    r#Call {
    },
    r#Other {
    },
    r#InvalidArgument {
    },
}



// Record definitions, implemented as method-less structs, corresponding to `dictionary` objects.


// Top level functions, corresponding to UDL `namespace` functions.// Object definitions, corresponding to UDL `interface` definitions.

// For each Object definition, we assume the caller has provided an appropriately-shaped `struct T`
// with an `impl` for each method on the object. We create an `Arc<T>` for "safely" handing out
// references to these structs to foreign language code, and we provide a `pub extern "C"` function
// corresponding to each method.
//
// (Note that "safely" is in "scare quotes" - that's because we use functions on an `Arc` that
// that are inherently unsafe, but the code we generate is safe in practice.)
//
// If the caller's implementation of the struct does not match with the methods or types specified
// in the UDL, then the rust compiler will complain with a (hopefully at least somewhat helpful!)
// error message when processing this generated code.
#[::uniffi::ffi_converter_interface(tag = crate::UniFfiTag)]
struct r#Scheduler { }


// All Object structs must be `Sync + Send`. The generated scaffolding will fail to compile
// if they are not, but unfortunately it fails with an unactionably obscure error message.
// By asserting the requirement explicitly, we help Rust produce a more scrutable error message
// and thus help the user debug why the requirement isn't being met.
uniffi::deps::static_assertions::assert_impl_all!(r#Scheduler: Sync, Send);

#[doc(hidden)]
#[no_mangle]
pub extern "C" fn uniffi_glclient_fn_free_scheduler(ptr: *const std::os::raw::c_void, call_status: &mut uniffi::RustCallStatus) {
    uniffi::rust_call(call_status, || {
        assert!(!ptr.is_null());
        drop(unsafe { ::std::sync::Arc::from_raw(ptr as *const r#Scheduler) });
        
        Ok(())
    })
}
    #[doc(hidden)]
    #[no_mangle]
    pub extern "C" fn r#uniffi_glclient_fn_constructor_scheduler_new(
        r#node_id: ::uniffi::RustBuffer,
        r#network: ::uniffi::RustBuffer,
    call_status: &mut uniffi::RustCallStatus
    ) -> *const std::os::raw::c_void /* *const Scheduler */ {
        uniffi::deps::log::debug!("uniffi_glclient_fn_constructor_scheduler_new");

        // If the constructor does not have the same signature as declared in the UDL, then
        // this attempt to call it will fail with a (somewhat) helpful compiler error.
        uniffi::rust_call(call_status, || {
            <::std::result::Result<std::sync::Arc<r#Scheduler>, r#Error> as ::uniffi::FfiConverter<crate::UniFfiTag>>::lower_return(
                r#Scheduler::r#new(
        match<Vec<u8> as ::uniffi::FfiConverter<crate::UniFfiTag>>::try_lift(r#node_id) {
        
            Ok(val) => val,
            Err(err) => return Err(uniffi::lower_anyhow_error_or_panic::<crate::UniFfiTag, r#Error>(err, "node_id")),
        },
        match<String as ::uniffi::FfiConverter<crate::UniFfiTag>>::try_lift(r#network) {
        
            Ok(val) => val,
            Err(err) => return Err(uniffi::lower_anyhow_error_or_panic::<crate::UniFfiTag, r#Error>(err, "network")),
        }).map(::std::sync::Arc::new).map_err(Into::into)
            )
        })
    }
    
#[doc(hidden)]
#[no_mangle]
#[allow(clippy::let_unit_value,clippy::unit_arg)] // The generated code uses the unit type like other types to keep things uniform
pub extern "C" fn r#uniffi_glclient_fn_method_scheduler_authenticate(
        r#ptr: *const std::os::raw::c_void,
        r#cert_pem: ::uniffi::RustBuffer,
        r#key_pem: ::uniffi::RustBuffer,
    call_status: &mut uniffi::RustCallStatus
)  {
    uniffi::deps::log::debug!("uniffi_glclient_fn_method_scheduler_authenticate");
    uniffi::rust_call(call_status, || {
        <::std::result::Result<(), r#Error> as ::uniffi::FfiConverter<crate::UniFfiTag>>::lower_return(
            <r#Scheduler>::r#authenticate(
        match<std::sync::Arc<r#Scheduler> as ::uniffi::FfiConverter<crate::UniFfiTag>>::try_lift(r#ptr) {
        
            Ok(ref val) => val,
            Err(err) => return Err(uniffi::lower_anyhow_error_or_panic::<crate::UniFfiTag, r#Error>(err, "ptr")),
        },
        match<Vec<u8> as ::uniffi::FfiConverter<crate::UniFfiTag>>::try_lift(r#cert_pem) {
        
            Ok(val) => val,
            Err(err) => return Err(uniffi::lower_anyhow_error_or_panic::<crate::UniFfiTag, r#Error>(err, "cert_pem")),
        },
        match<Vec<u8> as ::uniffi::FfiConverter<crate::UniFfiTag>>::try_lift(r#key_pem) {
        
            Ok(val) => val,
            Err(err) => return Err(uniffi::lower_anyhow_error_or_panic::<crate::UniFfiTag, r#Error>(err, "key_pem")),
        })
    
            .map_err(Into::into)
        )
    })
}



// For each Object definition, we assume the caller has provided an appropriately-shaped `struct T`
// with an `impl` for each method on the object. We create an `Arc<T>` for "safely" handing out
// references to these structs to foreign language code, and we provide a `pub extern "C"` function
// corresponding to each method.
//
// (Note that "safely" is in "scare quotes" - that's because we use functions on an `Arc` that
// that are inherently unsafe, but the code we generate is safe in practice.)
//
// If the caller's implementation of the struct does not match with the methods or types specified
// in the UDL, then the rust compiler will complain with a (hopefully at least somewhat helpful!)
// error message when processing this generated code.
#[::uniffi::ffi_converter_interface(tag = crate::UniFfiTag)]
struct r#RawClient { }


// All Object structs must be `Sync + Send`. The generated scaffolding will fail to compile
// if they are not, but unfortunately it fails with an unactionably obscure error message.
// By asserting the requirement explicitly, we help Rust produce a more scrutable error message
// and thus help the user debug why the requirement isn't being met.
uniffi::deps::static_assertions::assert_impl_all!(r#RawClient: Sync, Send);

#[doc(hidden)]
#[no_mangle]
pub extern "C" fn uniffi_glclient_fn_free_rawclient(ptr: *const std::os::raw::c_void, call_status: &mut uniffi::RustCallStatus) {
    uniffi::rust_call(call_status, || {
        assert!(!ptr.is_null());
        drop(unsafe { ::std::sync::Arc::from_raw(ptr as *const r#RawClient) });
        
        Ok(())
    })
}
    #[doc(hidden)]
    #[no_mangle]
    pub extern "C" fn r#uniffi_glclient_fn_constructor_rawclient_new(
        r#node_id: ::uniffi::RustBuffer,
        r#network: ::uniffi::RustBuffer,
        r#cert_pem: ::uniffi::RustBuffer,
        r#key_pem: ::uniffi::RustBuffer,
        r#node_uri: ::uniffi::RustBuffer,
    call_status: &mut uniffi::RustCallStatus
    ) -> *const std::os::raw::c_void /* *const RawClient */ {
        uniffi::deps::log::debug!("uniffi_glclient_fn_constructor_rawclient_new");

        // If the constructor does not have the same signature as declared in the UDL, then
        // this attempt to call it will fail with a (somewhat) helpful compiler error.
        uniffi::rust_call(call_status, || {
            <::std::result::Result<std::sync::Arc<r#RawClient>, r#Error> as ::uniffi::FfiConverter<crate::UniFfiTag>>::lower_return(
                r#RawClient::r#new(
        match<Vec<u8> as ::uniffi::FfiConverter<crate::UniFfiTag>>::try_lift(r#node_id) {
        
            Ok(val) => val,
            Err(err) => return Err(uniffi::lower_anyhow_error_or_panic::<crate::UniFfiTag, r#Error>(err, "node_id")),
        },
        match<String as ::uniffi::FfiConverter<crate::UniFfiTag>>::try_lift(r#network) {
        
            Ok(val) => val,
            Err(err) => return Err(uniffi::lower_anyhow_error_or_panic::<crate::UniFfiTag, r#Error>(err, "network")),
        },
        match<Vec<u8> as ::uniffi::FfiConverter<crate::UniFfiTag>>::try_lift(r#cert_pem) {
        
            Ok(val) => val,
            Err(err) => return Err(uniffi::lower_anyhow_error_or_panic::<crate::UniFfiTag, r#Error>(err, "cert_pem")),
        },
        match<Vec<u8> as ::uniffi::FfiConverter<crate::UniFfiTag>>::try_lift(r#key_pem) {
        
            Ok(val) => val,
            Err(err) => return Err(uniffi::lower_anyhow_error_or_panic::<crate::UniFfiTag, r#Error>(err, "key_pem")),
        },
        match<String as ::uniffi::FfiConverter<crate::UniFfiTag>>::try_lift(r#node_uri) {
        
            Ok(val) => val,
            Err(err) => return Err(uniffi::lower_anyhow_error_or_panic::<crate::UniFfiTag, r#Error>(err, "node_uri")),
        }).map(::std::sync::Arc::new).map_err(Into::into)
            )
        })
    }
    
#[doc(hidden)]
#[no_mangle]
#[allow(clippy::let_unit_value,clippy::unit_arg)] // The generated code uses the unit type like other types to keep things uniform
pub extern "C" fn r#uniffi_glclient_fn_method_rawclient_call(
        r#ptr: *const std::os::raw::c_void,
        r#method: ::uniffi::RustBuffer,
        r#payload: ::uniffi::RustBuffer,
    call_status: &mut uniffi::RustCallStatus
)  -> <Vec<u8> as ::uniffi::FfiConverter<crate::UniFfiTag>>::ReturnType {
    uniffi::deps::log::debug!("uniffi_glclient_fn_method_rawclient_call");
    uniffi::rust_call(call_status, || {
        <::std::result::Result<Vec<u8>, r#Error> as ::uniffi::FfiConverter<crate::UniFfiTag>>::lower_return(
            <r#RawClient>::r#call(
        match<std::sync::Arc<r#RawClient> as ::uniffi::FfiConverter<crate::UniFfiTag>>::try_lift(r#ptr) {
        
            Ok(ref val) => val,
            Err(err) => return Err(uniffi::lower_anyhow_error_or_panic::<crate::UniFfiTag, r#Error>(err, "ptr")),
        },
        match<String as ::uniffi::FfiConverter<crate::UniFfiTag>>::try_lift(r#method) {
        
            Ok(val) => val,
            Err(err) => return Err(uniffi::lower_anyhow_error_or_panic::<crate::UniFfiTag, r#Error>(err, "method")),
        },
        match<Vec<u8> as ::uniffi::FfiConverter<crate::UniFfiTag>>::try_lift(r#payload) {
        
            Ok(val) => val,
            Err(err) => return Err(uniffi::lower_anyhow_error_or_panic::<crate::UniFfiTag, r#Error>(err, "payload")),
        })
    
            .map_err(Into::into)
        )
    })
}




// Callback Interface definitions, corresponding to UDL `callback interface` definitions.


// External and Wrapped types
// Support for external types.

// Types with an external `FfiConverter`...


// For custom scaffolding types we need to generate an FfiConverter impl based on the
// UniffiCustomTypeConverter implementation that the library supplies


// Export scaffolding checksums

#[no_mangle]
#[doc(hidden)]
pub extern "C" fn r#uniffi_glclient_checksum_method_scheduler_authenticate() -> u16 {
    33183
}
#[no_mangle]
#[doc(hidden)]
pub extern "C" fn r#uniffi_glclient_checksum_method_rawclient_call() -> u16 {
    37495
}
#[no_mangle]
#[doc(hidden)]
pub extern "C" fn r#uniffi_glclient_checksum_constructor_scheduler_new() -> u16 {
    2930
}
#[no_mangle]
#[doc(hidden)]
pub extern "C" fn r#uniffi_glclient_checksum_constructor_rawclient_new() -> u16 {
    9265
}

// The `reexport_uniffi_scaffolding` macro
// Code to re-export the UniFFI scaffolding functions.
//
// Rust won't always re-export the functions from dependencies
// ([rust-lang#50007](https://github.com/rust-lang/rust/issues/50007))
//
// A workaround for this is to have the dependent crate reference a function from its dependency in
// an extern "C" function. This is clearly hacky and brittle, but at least we have some unittests
// that check if this works (fixtures/reexport-scaffolding-macro).
//
// The main way we use this macro is for that contain multiple UniFFI components (libxul,
// megazord).  The combined library has a cargo dependency for each component and calls
// uniffi_reexport_scaffolding!() for each one.

#[allow(missing_docs)]
#[doc(hidden)]
pub const fn uniffi_reexport_hack() {}

#[doc(hidden)]
#[macro_export]
macro_rules! uniffi_reexport_scaffolding {
    () => {
        #[doc(hidden)]
        #[no_mangle]
        pub extern "C" fn glclient_uniffi_reexport_hack() {
            $crate::uniffi_reexport_hack()
        }
    };
}