

# This file was autogenerated by some hot garbage in the `uniffi` crate.
# Trust me, you don't want to mess with it!

# Common helper code.
#
# Ideally this would live in a separate .py file where it can be unittested etc
# in isolation, and perhaps even published as a re-useable package.
#
# However, it's important that the details of how this helper code works (e.g. the
# way that different builtin types are passed across the FFI) exactly match what's
# expected by the rust code on the other side of the interface. In practice right
# now that means coming from the exact some version of `uniffi` that was used to
# compile the rust component. The easiest way to ensure this is to bundle the Python
# helpers directly inline like we're doing here.

from __future__ import annotations
import os
import sys
import ctypes
import enum
import struct
import contextlib
import datetime
import threading
import itertools
import traceback
import typing
import platform

# Used for default argument values
_DEFAULT = object() # type: typing.Any


class _UniffiRustBuffer(ctypes.Structure):
    _fields_ = [
        ("capacity", ctypes.c_uint64),
        ("len", ctypes.c_uint64),
        ("data", ctypes.POINTER(ctypes.c_char)),
    ]

    @staticmethod
    def default():
        return _UniffiRustBuffer(0, 0, None)

    @staticmethod
    def alloc(size):
        return _uniffi_rust_call(_UniffiLib.ffi_glsdk_rustbuffer_alloc, size)

    @staticmethod
    def reserve(rbuf, additional):
        return _uniffi_rust_call(_UniffiLib.ffi_glsdk_rustbuffer_reserve, rbuf, additional)

    def free(self):
        return _uniffi_rust_call(_UniffiLib.ffi_glsdk_rustbuffer_free, self)

    def __str__(self):
        return "_UniffiRustBuffer(capacity={}, len={}, data={})".format(
            self.capacity,
            self.len,
            self.data[0:self.len]
        )

    @contextlib.contextmanager
    def alloc_with_builder(*args):
        """Context-manger to allocate a buffer using a _UniffiRustBufferBuilder.

        The allocated buffer will be automatically freed if an error occurs, ensuring that
        we don't accidentally leak it.
        """
        builder = _UniffiRustBufferBuilder()
        try:
            yield builder
        except:
            builder.discard()
            raise

    @contextlib.contextmanager
    def consume_with_stream(self):
        """Context-manager to consume a buffer using a _UniffiRustBufferStream.

        The _UniffiRustBuffer will be freed once the context-manager exits, ensuring that we don't
        leak it even if an error occurs.
        """
        try:
            s = _UniffiRustBufferStream.from_rust_buffer(self)
            yield s
            if s.remaining() != 0:
                raise RuntimeError("junk data left in buffer at end of consume_with_stream")
        finally:
            self.free()

    @contextlib.contextmanager
    def read_with_stream(self):
        """Context-manager to read a buffer using a _UniffiRustBufferStream.

        This is like consume_with_stream, but doesn't free the buffer afterwards.
        It should only be used with borrowed `_UniffiRustBuffer` data.
        """
        s = _UniffiRustBufferStream.from_rust_buffer(self)
        yield s
        if s.remaining() != 0:
            raise RuntimeError("junk data left in buffer at end of read_with_stream")

class _UniffiForeignBytes(ctypes.Structure):
    _fields_ = [
        ("len", ctypes.c_int32),
        ("data", ctypes.POINTER(ctypes.c_char)),
    ]

    def __str__(self):
        return "_UniffiForeignBytes(len={}, data={})".format(self.len, self.data[0:self.len])


class _UniffiRustBufferStream:
    """
    Helper for structured reading of bytes from a _UniffiRustBuffer
    """

    def __init__(self, data, len):
        self.data = data
        self.len = len
        self.offset = 0

    @classmethod
    def from_rust_buffer(cls, buf):
        return cls(buf.data, buf.len)

    def remaining(self):
        return self.len - self.offset

    def _unpack_from(self, size, format):
        if self.offset + size > self.len:
            raise InternalError("read past end of rust buffer")
        value = struct.unpack(format, self.data[self.offset:self.offset+size])[0]
        self.offset += size
        return value

    def read(self, size):
        if self.offset + size > self.len:
            raise InternalError("read past end of rust buffer")
        data = self.data[self.offset:self.offset+size]
        self.offset += size
        return data

    def read_i8(self):
        return self._unpack_from(1, ">b")

    def read_u8(self):
        return self._unpack_from(1, ">B")

    def read_i16(self):
        return self._unpack_from(2, ">h")

    def read_u16(self):
        return self._unpack_from(2, ">H")

    def read_i32(self):
        return self._unpack_from(4, ">i")

    def read_u32(self):
        return self._unpack_from(4, ">I")

    def read_i64(self):
        return self._unpack_from(8, ">q")

    def read_u64(self):
        return self._unpack_from(8, ">Q")

    def read_float(self):
        v = self._unpack_from(4, ">f")
        return v

    def read_double(self):
        return self._unpack_from(8, ">d")

class _UniffiRustBufferBuilder:
    """
    Helper for structured writing of bytes into a _UniffiRustBuffer.
    """

    def __init__(self):
        self.rbuf = _UniffiRustBuffer.alloc(16)
        self.rbuf.len = 0

    def finalize(self):
        rbuf = self.rbuf
        self.rbuf = None
        return rbuf

    def discard(self):
        if self.rbuf is not None:
            rbuf = self.finalize()
            rbuf.free()

    @contextlib.contextmanager
    def _reserve(self, num_bytes):
        if self.rbuf.len + num_bytes > self.rbuf.capacity:
            self.rbuf = _UniffiRustBuffer.reserve(self.rbuf, num_bytes)
        yield None
        self.rbuf.len += num_bytes

    def _pack_into(self, size, format, value):
        with self._reserve(size):
            # XXX TODO: I feel like I should be able to use `struct.pack_into` here but can't figure it out.
            for i, byte in enumerate(struct.pack(format, value)):
                self.rbuf.data[self.rbuf.len + i] = byte

    def write(self, value):
        with self._reserve(len(value)):
            for i, byte in enumerate(value):
                self.rbuf.data[self.rbuf.len + i] = byte

    def write_i8(self, v):
        self._pack_into(1, ">b", v)

    def write_u8(self, v):
        self._pack_into(1, ">B", v)

    def write_i16(self, v):
        self._pack_into(2, ">h", v)

    def write_u16(self, v):
        self._pack_into(2, ">H", v)

    def write_i32(self, v):
        self._pack_into(4, ">i", v)

    def write_u32(self, v):
        self._pack_into(4, ">I", v)

    def write_i64(self, v):
        self._pack_into(8, ">q", v)

    def write_u64(self, v):
        self._pack_into(8, ">Q", v)

    def write_float(self, v):
        self._pack_into(4, ">f", v)

    def write_double(self, v):
        self._pack_into(8, ">d", v)

    def write_c_size_t(self, v):
        self._pack_into(ctypes.sizeof(ctypes.c_size_t) , "@N", v)
# A handful of classes and functions to support the generated data structures.
# This would be a good candidate for isolating in its own ffi-support lib.

class InternalError(Exception):
    pass

class _UniffiRustCallStatus(ctypes.Structure):
    """
    Error runtime.
    """
    _fields_ = [
        ("code", ctypes.c_int8),
        ("error_buf", _UniffiRustBuffer),
    ]

    # These match the values from the uniffi::rustcalls module
    CALL_SUCCESS = 0
    CALL_ERROR = 1
    CALL_UNEXPECTED_ERROR = 2

    @staticmethod
    def default():
        return _UniffiRustCallStatus(code=_UniffiRustCallStatus.CALL_SUCCESS, error_buf=_UniffiRustBuffer.default())

    def __str__(self):
        if self.code == _UniffiRustCallStatus.CALL_SUCCESS:
            return "_UniffiRustCallStatus(CALL_SUCCESS)"
        elif self.code == _UniffiRustCallStatus.CALL_ERROR:
            return "_UniffiRustCallStatus(CALL_ERROR)"
        elif self.code == _UniffiRustCallStatus.CALL_UNEXPECTED_ERROR:
            return "_UniffiRustCallStatus(CALL_UNEXPECTED_ERROR)"
        else:
            return "_UniffiRustCallStatus(<invalid code>)"

def _uniffi_rust_call(fn, *args):
    # Call a rust function
    return _uniffi_rust_call_with_error(None, fn, *args)

def _uniffi_rust_call_with_error(error_ffi_converter, fn, *args):
    # Call a rust function and handle any errors
    #
    # This function is used for rust calls that return Result<> and therefore can set the CALL_ERROR status code.
    # error_ffi_converter must be set to the _UniffiConverter for the error class that corresponds to the result.
    call_status = _UniffiRustCallStatus.default()

    args_with_error = args + (ctypes.byref(call_status),)
    result = fn(*args_with_error)
    _uniffi_check_call_status(error_ffi_converter, call_status)
    return result

def _uniffi_check_call_status(error_ffi_converter, call_status):
    if call_status.code == _UniffiRustCallStatus.CALL_SUCCESS:
        pass
    elif call_status.code == _UniffiRustCallStatus.CALL_ERROR:
        if error_ffi_converter is None:
            call_status.error_buf.free()
            raise InternalError("_uniffi_rust_call_with_error: CALL_ERROR, but error_ffi_converter is None")
        else:
            raise error_ffi_converter.lift(call_status.error_buf)
    elif call_status.code == _UniffiRustCallStatus.CALL_UNEXPECTED_ERROR:
        # When the rust code sees a panic, it tries to construct a _UniffiRustBuffer
        # with the message.  But if that code panics, then it just sends back
        # an empty buffer.
        if call_status.error_buf.len > 0:
            msg = _UniffiConverterString.lift(call_status.error_buf)
        else:
            msg = "Unknown rust panic"
        raise InternalError(msg)
    else:
        raise InternalError("Invalid _UniffiRustCallStatus code: {}".format(
            call_status.code))

def _uniffi_trait_interface_call(call_status, make_call, write_return_value):
    try:
        return write_return_value(make_call())
    except Exception as e:
        call_status.code = _UniffiRustCallStatus.CALL_UNEXPECTED_ERROR
        call_status.error_buf = _UniffiConverterString.lower(repr(e))

def _uniffi_trait_interface_call_with_error(call_status, make_call, write_return_value, error_type, lower_error):
    try:
        try:
            return write_return_value(make_call())
        except error_type as e:
            call_status.code = _UniffiRustCallStatus.CALL_ERROR
            call_status.error_buf = lower_error(e)
    except Exception as e:
        call_status.code = _UniffiRustCallStatus.CALL_UNEXPECTED_ERROR
        call_status.error_buf = _UniffiConverterString.lower(repr(e))
class _UniffiHandleMap:
    """
    A map where inserting, getting and removing data is synchronized with a lock.
    """

    def __init__(self):
        # type Handle = int
        self._map = {}  # type: Dict[Handle, Any]
        self._lock = threading.Lock()
        self._counter = itertools.count()

    def insert(self, obj):
        with self._lock:
            handle = next(self._counter)
            self._map[handle] = obj
            return handle

    def get(self, handle):
        try:
            with self._lock:
                return self._map[handle]
        except KeyError:
            raise InternalError("_UniffiHandleMap.get: Invalid handle")

    def remove(self, handle):
        try:
            with self._lock:
                return self._map.pop(handle)
        except KeyError:
            raise InternalError("_UniffiHandleMap.remove: Invalid handle")

    def __len__(self):
        return len(self._map)
# Types conforming to `_UniffiConverterPrimitive` pass themselves directly over the FFI.
class _UniffiConverterPrimitive:
    @classmethod
    def lift(cls, value):
        return value

    @classmethod
    def lower(cls, value):
        return value

class _UniffiConverterPrimitiveInt(_UniffiConverterPrimitive):
    @classmethod
    def check_lower(cls, value):
        try:
            value = value.__index__()
        except Exception:
            raise TypeError("'{}' object cannot be interpreted as an integer".format(type(value).__name__))
        if not isinstance(value, int):
            raise TypeError("__index__ returned non-int (type {})".format(type(value).__name__))
        if not cls.VALUE_MIN <= value < cls.VALUE_MAX:
            raise ValueError("{} requires {} <= value < {}".format(cls.CLASS_NAME, cls.VALUE_MIN, cls.VALUE_MAX))

class _UniffiConverterPrimitiveFloat(_UniffiConverterPrimitive):
    @classmethod
    def check_lower(cls, value):
        try:
            value = value.__float__()
        except Exception:
            raise TypeError("must be real number, not {}".format(type(value).__name__))
        if not isinstance(value, float):
            raise TypeError("__float__ returned non-float (type {})".format(type(value).__name__))

# Helper class for wrapper types that will always go through a _UniffiRustBuffer.
# Classes should inherit from this and implement the `read` and `write` static methods.
class _UniffiConverterRustBuffer:
    @classmethod
    def lift(cls, rbuf):
        with rbuf.consume_with_stream() as stream:
            return cls.read(stream)

    @classmethod
    def lower(cls, value):
        with _UniffiRustBuffer.alloc_with_builder() as builder:
            cls.write(value, builder)
            return builder.finalize()

# Contains loading, initialization code, and the FFI Function declarations.
# Define some ctypes FFI types that we use in the library

"""
Function pointer for a Rust task, which a callback function that takes a opaque pointer
"""
_UNIFFI_RUST_TASK = ctypes.CFUNCTYPE(None, ctypes.c_void_p, ctypes.c_int8)

def _uniffi_future_callback_t(return_type):
    """
    Factory function to create callback function types for async functions
    """
    return ctypes.CFUNCTYPE(None, ctypes.c_uint64, return_type, _UniffiRustCallStatus)

def _uniffi_load_indirect():
    """
    This is how we find and load the dynamic library provided by the component.
    For now we just look it up by name.
    """
    if sys.platform == "darwin":
        libname = "lib{}.dylib"
    elif sys.platform.startswith("win"):
        # As of python3.8, ctypes does not seem to search $PATH when loading DLLs.
        # We could use `os.add_dll_directory` to configure the search path, but
        # it doesn't feel right to mess with application-wide settings. Let's
        # assume that the `.dll` is next to the `.py` file and load by full path.
        libname = os.path.join(
            os.path.dirname(__file__),
            "{}.dll",
        )
    else:
        # Anything else must be an ELF platform - Linux, *BSD, Solaris/illumos
        libname = "lib{}.so"

    libname = libname.format("glsdk")
    path = os.path.join(os.path.dirname(__file__), libname)
    lib = ctypes.cdll.LoadLibrary(path)
    return lib

def _uniffi_check_contract_api_version(lib):
    # Get the bindings contract version from our ComponentInterface
    bindings_contract_version = 29
    # Get the scaffolding contract version by calling the into the dylib
    scaffolding_contract_version = lib.ffi_glsdk_uniffi_contract_version()
    if bindings_contract_version != scaffolding_contract_version:
        raise InternalError("UniFFI contract version mismatch: try cleaning and rebuilding your project")

def _uniffi_check_api_checksums(lib):
    if lib.uniffi_glsdk_checksum_method_credentials_save() != 26677:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glsdk_checksum_method_handle_stop() != 36432:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glsdk_checksum_method_node_get_info() != 39460:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glsdk_checksum_method_node_list_funds() != 21692:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glsdk_checksum_method_node_list_peer_channels() != 35210:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glsdk_checksum_method_node_list_peers() != 29567:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glsdk_checksum_method_node_onchain_receive() != 57530:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glsdk_checksum_method_node_onchain_send() != 44346:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glsdk_checksum_method_node_receive() != 39761:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glsdk_checksum_method_node_send() != 4348:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glsdk_checksum_method_node_stop() != 20186:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glsdk_checksum_method_node_stream_node_events() != 5933:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glsdk_checksum_method_nodeeventstream_next() != 12635:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glsdk_checksum_method_scheduler_recover() != 55514:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glsdk_checksum_method_scheduler_register() != 20821:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glsdk_checksum_method_signer_authenticate() != 55935:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glsdk_checksum_method_signer_node_id() != 43931:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glsdk_checksum_method_signer_start() != 9404:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glsdk_checksum_constructor_credentials_load() != 25306:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glsdk_checksum_constructor_node_new() != 7003:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glsdk_checksum_constructor_scheduler_new() != 15239:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_glsdk_checksum_constructor_signer_new() != 62159:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")

# A ctypes library to expose the extern-C FFI definitions.
# This is an implementation detail which will be called internally by the public API.

_UniffiLib = _uniffi_load_indirect()
_UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK = ctypes.CFUNCTYPE(None,ctypes.c_uint64,ctypes.c_int8,
)
_UNIFFI_FOREIGN_FUTURE_FREE = ctypes.CFUNCTYPE(None,ctypes.c_uint64,
)
_UNIFFI_CALLBACK_INTERFACE_FREE = ctypes.CFUNCTYPE(None,ctypes.c_uint64,
)
class _UniffiForeignFuture(ctypes.Structure):
    _fields_ = [
        ("handle", ctypes.c_uint64),
        ("free", _UNIFFI_FOREIGN_FUTURE_FREE),
    ]
class _UniffiForeignFutureStructU8(ctypes.Structure):
    _fields_ = [
        ("return_value", ctypes.c_uint8),
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_U8 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructU8,
)
class _UniffiForeignFutureStructI8(ctypes.Structure):
    _fields_ = [
        ("return_value", ctypes.c_int8),
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_I8 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructI8,
)
class _UniffiForeignFutureStructU16(ctypes.Structure):
    _fields_ = [
        ("return_value", ctypes.c_uint16),
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_U16 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructU16,
)
class _UniffiForeignFutureStructI16(ctypes.Structure):
    _fields_ = [
        ("return_value", ctypes.c_int16),
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_I16 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructI16,
)
class _UniffiForeignFutureStructU32(ctypes.Structure):
    _fields_ = [
        ("return_value", ctypes.c_uint32),
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_U32 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructU32,
)
class _UniffiForeignFutureStructI32(ctypes.Structure):
    _fields_ = [
        ("return_value", ctypes.c_int32),
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_I32 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructI32,
)
class _UniffiForeignFutureStructU64(ctypes.Structure):
    _fields_ = [
        ("return_value", ctypes.c_uint64),
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_U64 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructU64,
)
class _UniffiForeignFutureStructI64(ctypes.Structure):
    _fields_ = [
        ("return_value", ctypes.c_int64),
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_I64 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructI64,
)
class _UniffiForeignFutureStructF32(ctypes.Structure):
    _fields_ = [
        ("return_value", ctypes.c_float),
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_F32 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructF32,
)
class _UniffiForeignFutureStructF64(ctypes.Structure):
    _fields_ = [
        ("return_value", ctypes.c_double),
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_F64 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructF64,
)
class _UniffiForeignFutureStructPointer(ctypes.Structure):
    _fields_ = [
        ("return_value", ctypes.c_void_p),
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_POINTER = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructPointer,
)
class _UniffiForeignFutureStructRustBuffer(ctypes.Structure):
    _fields_ = [
        ("return_value", _UniffiRustBuffer),
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_RUST_BUFFER = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructRustBuffer,
)
class _UniffiForeignFutureStructVoid(ctypes.Structure):
    _fields_ = [
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_VOID = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructVoid,
)
_UniffiLib.uniffi_glsdk_fn_clone_credentials.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_glsdk_fn_clone_credentials.restype = ctypes.c_void_p
_UniffiLib.uniffi_glsdk_fn_free_credentials.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_glsdk_fn_free_credentials.restype = None
_UniffiLib.uniffi_glsdk_fn_constructor_credentials_load.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_glsdk_fn_constructor_credentials_load.restype = ctypes.c_void_p
_UniffiLib.uniffi_glsdk_fn_method_credentials_save.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_glsdk_fn_method_credentials_save.restype = _UniffiRustBuffer
_UniffiLib.uniffi_glsdk_fn_clone_handle.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_glsdk_fn_clone_handle.restype = ctypes.c_void_p
_UniffiLib.uniffi_glsdk_fn_free_handle.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_glsdk_fn_free_handle.restype = None
_UniffiLib.uniffi_glsdk_fn_method_handle_stop.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_glsdk_fn_method_handle_stop.restype = None
_UniffiLib.uniffi_glsdk_fn_clone_node.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_glsdk_fn_clone_node.restype = ctypes.c_void_p
_UniffiLib.uniffi_glsdk_fn_free_node.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_glsdk_fn_free_node.restype = None
_UniffiLib.uniffi_glsdk_fn_constructor_node_new.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_glsdk_fn_constructor_node_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_glsdk_fn_method_node_get_info.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_glsdk_fn_method_node_get_info.restype = _UniffiRustBuffer
_UniffiLib.uniffi_glsdk_fn_method_node_list_funds.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_glsdk_fn_method_node_list_funds.restype = _UniffiRustBuffer
_UniffiLib.uniffi_glsdk_fn_method_node_list_peer_channels.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_glsdk_fn_method_node_list_peer_channels.restype = _UniffiRustBuffer
_UniffiLib.uniffi_glsdk_fn_method_node_list_peers.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_glsdk_fn_method_node_list_peers.restype = _UniffiRustBuffer
_UniffiLib.uniffi_glsdk_fn_method_node_onchain_receive.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_glsdk_fn_method_node_onchain_receive.restype = _UniffiRustBuffer
_UniffiLib.uniffi_glsdk_fn_method_node_onchain_send.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_glsdk_fn_method_node_onchain_send.restype = _UniffiRustBuffer
_UniffiLib.uniffi_glsdk_fn_method_node_receive.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_glsdk_fn_method_node_receive.restype = _UniffiRustBuffer
_UniffiLib.uniffi_glsdk_fn_method_node_send.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_glsdk_fn_method_node_send.restype = _UniffiRustBuffer
_UniffiLib.uniffi_glsdk_fn_method_node_stop.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_glsdk_fn_method_node_stop.restype = None
_UniffiLib.uniffi_glsdk_fn_method_node_stream_node_events.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_glsdk_fn_method_node_stream_node_events.restype = ctypes.c_void_p
_UniffiLib.uniffi_glsdk_fn_clone_nodeeventstream.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_glsdk_fn_clone_nodeeventstream.restype = ctypes.c_void_p
_UniffiLib.uniffi_glsdk_fn_free_nodeeventstream.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_glsdk_fn_free_nodeeventstream.restype = None
_UniffiLib.uniffi_glsdk_fn_method_nodeeventstream_next.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_glsdk_fn_method_nodeeventstream_next.restype = _UniffiRustBuffer
_UniffiLib.uniffi_glsdk_fn_clone_scheduler.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_glsdk_fn_clone_scheduler.restype = ctypes.c_void_p
_UniffiLib.uniffi_glsdk_fn_free_scheduler.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_glsdk_fn_free_scheduler.restype = None
_UniffiLib.uniffi_glsdk_fn_constructor_scheduler_new.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_glsdk_fn_constructor_scheduler_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_glsdk_fn_method_scheduler_recover.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_glsdk_fn_method_scheduler_recover.restype = ctypes.c_void_p
_UniffiLib.uniffi_glsdk_fn_method_scheduler_register.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_glsdk_fn_method_scheduler_register.restype = ctypes.c_void_p
_UniffiLib.uniffi_glsdk_fn_clone_signer.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_glsdk_fn_clone_signer.restype = ctypes.c_void_p
_UniffiLib.uniffi_glsdk_fn_free_signer.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_glsdk_fn_free_signer.restype = None
_UniffiLib.uniffi_glsdk_fn_constructor_signer_new.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_glsdk_fn_constructor_signer_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_glsdk_fn_method_signer_authenticate.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_glsdk_fn_method_signer_authenticate.restype = ctypes.c_void_p
_UniffiLib.uniffi_glsdk_fn_method_signer_node_id.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_glsdk_fn_method_signer_node_id.restype = _UniffiRustBuffer
_UniffiLib.uniffi_glsdk_fn_method_signer_start.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_glsdk_fn_method_signer_start.restype = ctypes.c_void_p
_UniffiLib.ffi_glsdk_rustbuffer_alloc.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_glsdk_rustbuffer_alloc.restype = _UniffiRustBuffer
_UniffiLib.ffi_glsdk_rustbuffer_from_bytes.argtypes = (
    _UniffiForeignBytes,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_glsdk_rustbuffer_from_bytes.restype = _UniffiRustBuffer
_UniffiLib.ffi_glsdk_rustbuffer_free.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_glsdk_rustbuffer_free.restype = None
_UniffiLib.ffi_glsdk_rustbuffer_reserve.argtypes = (
    _UniffiRustBuffer,
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_glsdk_rustbuffer_reserve.restype = _UniffiRustBuffer
_UniffiLib.ffi_glsdk_rust_future_poll_u8.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_glsdk_rust_future_poll_u8.restype = None
_UniffiLib.ffi_glsdk_rust_future_cancel_u8.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_glsdk_rust_future_cancel_u8.restype = None
_UniffiLib.ffi_glsdk_rust_future_free_u8.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_glsdk_rust_future_free_u8.restype = None
_UniffiLib.ffi_glsdk_rust_future_complete_u8.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_glsdk_rust_future_complete_u8.restype = ctypes.c_uint8
_UniffiLib.ffi_glsdk_rust_future_poll_i8.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_glsdk_rust_future_poll_i8.restype = None
_UniffiLib.ffi_glsdk_rust_future_cancel_i8.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_glsdk_rust_future_cancel_i8.restype = None
_UniffiLib.ffi_glsdk_rust_future_free_i8.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_glsdk_rust_future_free_i8.restype = None
_UniffiLib.ffi_glsdk_rust_future_complete_i8.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_glsdk_rust_future_complete_i8.restype = ctypes.c_int8
_UniffiLib.ffi_glsdk_rust_future_poll_u16.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_glsdk_rust_future_poll_u16.restype = None
_UniffiLib.ffi_glsdk_rust_future_cancel_u16.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_glsdk_rust_future_cancel_u16.restype = None
_UniffiLib.ffi_glsdk_rust_future_free_u16.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_glsdk_rust_future_free_u16.restype = None
_UniffiLib.ffi_glsdk_rust_future_complete_u16.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_glsdk_rust_future_complete_u16.restype = ctypes.c_uint16
_UniffiLib.ffi_glsdk_rust_future_poll_i16.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_glsdk_rust_future_poll_i16.restype = None
_UniffiLib.ffi_glsdk_rust_future_cancel_i16.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_glsdk_rust_future_cancel_i16.restype = None
_UniffiLib.ffi_glsdk_rust_future_free_i16.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_glsdk_rust_future_free_i16.restype = None
_UniffiLib.ffi_glsdk_rust_future_complete_i16.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_glsdk_rust_future_complete_i16.restype = ctypes.c_int16
_UniffiLib.ffi_glsdk_rust_future_poll_u32.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_glsdk_rust_future_poll_u32.restype = None
_UniffiLib.ffi_glsdk_rust_future_cancel_u32.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_glsdk_rust_future_cancel_u32.restype = None
_UniffiLib.ffi_glsdk_rust_future_free_u32.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_glsdk_rust_future_free_u32.restype = None
_UniffiLib.ffi_glsdk_rust_future_complete_u32.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_glsdk_rust_future_complete_u32.restype = ctypes.c_uint32
_UniffiLib.ffi_glsdk_rust_future_poll_i32.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_glsdk_rust_future_poll_i32.restype = None
_UniffiLib.ffi_glsdk_rust_future_cancel_i32.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_glsdk_rust_future_cancel_i32.restype = None
_UniffiLib.ffi_glsdk_rust_future_free_i32.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_glsdk_rust_future_free_i32.restype = None
_UniffiLib.ffi_glsdk_rust_future_complete_i32.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_glsdk_rust_future_complete_i32.restype = ctypes.c_int32
_UniffiLib.ffi_glsdk_rust_future_poll_u64.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_glsdk_rust_future_poll_u64.restype = None
_UniffiLib.ffi_glsdk_rust_future_cancel_u64.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_glsdk_rust_future_cancel_u64.restype = None
_UniffiLib.ffi_glsdk_rust_future_free_u64.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_glsdk_rust_future_free_u64.restype = None
_UniffiLib.ffi_glsdk_rust_future_complete_u64.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_glsdk_rust_future_complete_u64.restype = ctypes.c_uint64
_UniffiLib.ffi_glsdk_rust_future_poll_i64.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_glsdk_rust_future_poll_i64.restype = None
_UniffiLib.ffi_glsdk_rust_future_cancel_i64.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_glsdk_rust_future_cancel_i64.restype = None
_UniffiLib.ffi_glsdk_rust_future_free_i64.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_glsdk_rust_future_free_i64.restype = None
_UniffiLib.ffi_glsdk_rust_future_complete_i64.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_glsdk_rust_future_complete_i64.restype = ctypes.c_int64
_UniffiLib.ffi_glsdk_rust_future_poll_f32.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_glsdk_rust_future_poll_f32.restype = None
_UniffiLib.ffi_glsdk_rust_future_cancel_f32.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_glsdk_rust_future_cancel_f32.restype = None
_UniffiLib.ffi_glsdk_rust_future_free_f32.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_glsdk_rust_future_free_f32.restype = None
_UniffiLib.ffi_glsdk_rust_future_complete_f32.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_glsdk_rust_future_complete_f32.restype = ctypes.c_float
_UniffiLib.ffi_glsdk_rust_future_poll_f64.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_glsdk_rust_future_poll_f64.restype = None
_UniffiLib.ffi_glsdk_rust_future_cancel_f64.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_glsdk_rust_future_cancel_f64.restype = None
_UniffiLib.ffi_glsdk_rust_future_free_f64.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_glsdk_rust_future_free_f64.restype = None
_UniffiLib.ffi_glsdk_rust_future_complete_f64.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_glsdk_rust_future_complete_f64.restype = ctypes.c_double
_UniffiLib.ffi_glsdk_rust_future_poll_pointer.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_glsdk_rust_future_poll_pointer.restype = None
_UniffiLib.ffi_glsdk_rust_future_cancel_pointer.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_glsdk_rust_future_cancel_pointer.restype = None
_UniffiLib.ffi_glsdk_rust_future_free_pointer.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_glsdk_rust_future_free_pointer.restype = None
_UniffiLib.ffi_glsdk_rust_future_complete_pointer.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_glsdk_rust_future_complete_pointer.restype = ctypes.c_void_p
_UniffiLib.ffi_glsdk_rust_future_poll_rust_buffer.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_glsdk_rust_future_poll_rust_buffer.restype = None
_UniffiLib.ffi_glsdk_rust_future_cancel_rust_buffer.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_glsdk_rust_future_cancel_rust_buffer.restype = None
_UniffiLib.ffi_glsdk_rust_future_free_rust_buffer.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_glsdk_rust_future_free_rust_buffer.restype = None
_UniffiLib.ffi_glsdk_rust_future_complete_rust_buffer.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_glsdk_rust_future_complete_rust_buffer.restype = _UniffiRustBuffer
_UniffiLib.ffi_glsdk_rust_future_poll_void.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_glsdk_rust_future_poll_void.restype = None
_UniffiLib.ffi_glsdk_rust_future_cancel_void.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_glsdk_rust_future_cancel_void.restype = None
_UniffiLib.ffi_glsdk_rust_future_free_void.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_glsdk_rust_future_free_void.restype = None
_UniffiLib.ffi_glsdk_rust_future_complete_void.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_glsdk_rust_future_complete_void.restype = None
_UniffiLib.uniffi_glsdk_checksum_method_credentials_save.argtypes = (
)
_UniffiLib.uniffi_glsdk_checksum_method_credentials_save.restype = ctypes.c_uint16
_UniffiLib.uniffi_glsdk_checksum_method_handle_stop.argtypes = (
)
_UniffiLib.uniffi_glsdk_checksum_method_handle_stop.restype = ctypes.c_uint16
_UniffiLib.uniffi_glsdk_checksum_method_node_get_info.argtypes = (
)
_UniffiLib.uniffi_glsdk_checksum_method_node_get_info.restype = ctypes.c_uint16
_UniffiLib.uniffi_glsdk_checksum_method_node_list_funds.argtypes = (
)
_UniffiLib.uniffi_glsdk_checksum_method_node_list_funds.restype = ctypes.c_uint16
_UniffiLib.uniffi_glsdk_checksum_method_node_list_peer_channels.argtypes = (
)
_UniffiLib.uniffi_glsdk_checksum_method_node_list_peer_channels.restype = ctypes.c_uint16
_UniffiLib.uniffi_glsdk_checksum_method_node_list_peers.argtypes = (
)
_UniffiLib.uniffi_glsdk_checksum_method_node_list_peers.restype = ctypes.c_uint16
_UniffiLib.uniffi_glsdk_checksum_method_node_onchain_receive.argtypes = (
)
_UniffiLib.uniffi_glsdk_checksum_method_node_onchain_receive.restype = ctypes.c_uint16
_UniffiLib.uniffi_glsdk_checksum_method_node_onchain_send.argtypes = (
)
_UniffiLib.uniffi_glsdk_checksum_method_node_onchain_send.restype = ctypes.c_uint16
_UniffiLib.uniffi_glsdk_checksum_method_node_receive.argtypes = (
)
_UniffiLib.uniffi_glsdk_checksum_method_node_receive.restype = ctypes.c_uint16
_UniffiLib.uniffi_glsdk_checksum_method_node_send.argtypes = (
)
_UniffiLib.uniffi_glsdk_checksum_method_node_send.restype = ctypes.c_uint16
_UniffiLib.uniffi_glsdk_checksum_method_node_stop.argtypes = (
)
_UniffiLib.uniffi_glsdk_checksum_method_node_stop.restype = ctypes.c_uint16
_UniffiLib.uniffi_glsdk_checksum_method_node_stream_node_events.argtypes = (
)
_UniffiLib.uniffi_glsdk_checksum_method_node_stream_node_events.restype = ctypes.c_uint16
_UniffiLib.uniffi_glsdk_checksum_method_nodeeventstream_next.argtypes = (
)
_UniffiLib.uniffi_glsdk_checksum_method_nodeeventstream_next.restype = ctypes.c_uint16
_UniffiLib.uniffi_glsdk_checksum_method_scheduler_recover.argtypes = (
)
_UniffiLib.uniffi_glsdk_checksum_method_scheduler_recover.restype = ctypes.c_uint16
_UniffiLib.uniffi_glsdk_checksum_method_scheduler_register.argtypes = (
)
_UniffiLib.uniffi_glsdk_checksum_method_scheduler_register.restype = ctypes.c_uint16
_UniffiLib.uniffi_glsdk_checksum_method_signer_authenticate.argtypes = (
)
_UniffiLib.uniffi_glsdk_checksum_method_signer_authenticate.restype = ctypes.c_uint16
_UniffiLib.uniffi_glsdk_checksum_method_signer_node_id.argtypes = (
)
_UniffiLib.uniffi_glsdk_checksum_method_signer_node_id.restype = ctypes.c_uint16
_UniffiLib.uniffi_glsdk_checksum_method_signer_start.argtypes = (
)
_UniffiLib.uniffi_glsdk_checksum_method_signer_start.restype = ctypes.c_uint16
_UniffiLib.uniffi_glsdk_checksum_constructor_credentials_load.argtypes = (
)
_UniffiLib.uniffi_glsdk_checksum_constructor_credentials_load.restype = ctypes.c_uint16
_UniffiLib.uniffi_glsdk_checksum_constructor_node_new.argtypes = (
)
_UniffiLib.uniffi_glsdk_checksum_constructor_node_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_glsdk_checksum_constructor_scheduler_new.argtypes = (
)
_UniffiLib.uniffi_glsdk_checksum_constructor_scheduler_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_glsdk_checksum_constructor_signer_new.argtypes = (
)
_UniffiLib.uniffi_glsdk_checksum_constructor_signer_new.restype = ctypes.c_uint16
_UniffiLib.ffi_glsdk_uniffi_contract_version.argtypes = (
)
_UniffiLib.ffi_glsdk_uniffi_contract_version.restype = ctypes.c_uint32

_uniffi_check_contract_api_version(_UniffiLib)
# _uniffi_check_api_checksums(_UniffiLib)

# Public interface members begin here.


class _UniffiConverterUInt32(_UniffiConverterPrimitiveInt):
    CLASS_NAME = "u32"
    VALUE_MIN = 0
    VALUE_MAX = 2**32

    @staticmethod
    def read(buf):
        return buf.read_u32()

    @staticmethod
    def write(value, buf):
        buf.write_u32(value)

class _UniffiConverterUInt64(_UniffiConverterPrimitiveInt):
    CLASS_NAME = "u64"
    VALUE_MIN = 0
    VALUE_MAX = 2**64

    @staticmethod
    def read(buf):
        return buf.read_u64()

    @staticmethod
    def write(value, buf):
        buf.write_u64(value)

class _UniffiConverterBool:
    @classmethod
    def check_lower(cls, value):
        return not not value

    @classmethod
    def lower(cls, value):
        return 1 if value else 0

    @staticmethod
    def lift(value):
        return value != 0

    @classmethod
    def read(cls, buf):
        return cls.lift(buf.read_u8())

    @classmethod
    def write(cls, value, buf):
        buf.write_u8(value)

class _UniffiConverterString:
    @staticmethod
    def check_lower(value):
        if not isinstance(value, str):
            raise TypeError("argument must be str, not {}".format(type(value).__name__))
        return value

    @staticmethod
    def read(buf):
        size = buf.read_i32()
        if size < 0:
            raise InternalError("Unexpected negative string length")
        utf8_bytes = buf.read(size)
        return utf8_bytes.decode("utf-8")

    @staticmethod
    def write(value, buf):
        utf8_bytes = value.encode("utf-8")
        buf.write_i32(len(utf8_bytes))
        buf.write(utf8_bytes)

    @staticmethod
    def lift(buf):
        with buf.consume_with_stream() as stream:
            return stream.read(stream.remaining()).decode("utf-8")

    @staticmethod
    def lower(value):
        with _UniffiRustBuffer.alloc_with_builder() as builder:
            builder.write(value.encode("utf-8"))
            return builder.finalize()

class _UniffiConverterBytes(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        size = buf.read_i32()
        if size < 0:
            raise InternalError("Unexpected negative byte string length")
        return buf.read(size)

    @staticmethod
    def check_lower(value):
        try:
            memoryview(value)
        except TypeError:
            raise TypeError("a bytes-like object is required, not {!r}".format(type(value).__name__))

    @staticmethod
    def write(value, buf):
        buf.write_i32(len(value))
        buf.write(value)














class FundChannel:
    peer_id: "bytes"
    our_amount_msat: "int"
    amount_msat: "int"
    funding_txid: "bytes"
    funding_output: "int"
    connected: "bool"
    state: "ChannelState"
    short_channel_id: "typing.Optional[str]"
    channel_id: "typing.Optional[bytes]"
    def __init__(self, *, peer_id: "bytes", our_amount_msat: "int", amount_msat: "int", funding_txid: "bytes", funding_output: "int", connected: "bool", state: "ChannelState", short_channel_id: "typing.Optional[str]", channel_id: "typing.Optional[bytes]"):
        self.peer_id = peer_id
        self.our_amount_msat = our_amount_msat
        self.amount_msat = amount_msat
        self.funding_txid = funding_txid
        self.funding_output = funding_output
        self.connected = connected
        self.state = state
        self.short_channel_id = short_channel_id
        self.channel_id = channel_id

    def __str__(self):
        return "FundChannel(peer_id={}, our_amount_msat={}, amount_msat={}, funding_txid={}, funding_output={}, connected={}, state={}, short_channel_id={}, channel_id={})".format(self.peer_id, self.our_amount_msat, self.amount_msat, self.funding_txid, self.funding_output, self.connected, self.state, self.short_channel_id, self.channel_id)

    def __eq__(self, other):
        if self.peer_id != other.peer_id:
            return False
        if self.our_amount_msat != other.our_amount_msat:
            return False
        if self.amount_msat != other.amount_msat:
            return False
        if self.funding_txid != other.funding_txid:
            return False
        if self.funding_output != other.funding_output:
            return False
        if self.connected != other.connected:
            return False
        if self.state != other.state:
            return False
        if self.short_channel_id != other.short_channel_id:
            return False
        if self.channel_id != other.channel_id:
            return False
        return True

class _UniffiConverterTypeFundChannel(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return FundChannel(
            peer_id=_UniffiConverterBytes.read(buf),
            our_amount_msat=_UniffiConverterUInt64.read(buf),
            amount_msat=_UniffiConverterUInt64.read(buf),
            funding_txid=_UniffiConverterBytes.read(buf),
            funding_output=_UniffiConverterUInt32.read(buf),
            connected=_UniffiConverterBool.read(buf),
            state=_UniffiConverterTypeChannelState.read(buf),
            short_channel_id=_UniffiConverterOptionalString.read(buf),
            channel_id=_UniffiConverterOptionalBytes.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterBytes.check_lower(value.peer_id)
        _UniffiConverterUInt64.check_lower(value.our_amount_msat)
        _UniffiConverterUInt64.check_lower(value.amount_msat)
        _UniffiConverterBytes.check_lower(value.funding_txid)
        _UniffiConverterUInt32.check_lower(value.funding_output)
        _UniffiConverterBool.check_lower(value.connected)
        _UniffiConverterTypeChannelState.check_lower(value.state)
        _UniffiConverterOptionalString.check_lower(value.short_channel_id)
        _UniffiConverterOptionalBytes.check_lower(value.channel_id)

    @staticmethod
    def write(value, buf):
        _UniffiConverterBytes.write(value.peer_id, buf)
        _UniffiConverterUInt64.write(value.our_amount_msat, buf)
        _UniffiConverterUInt64.write(value.amount_msat, buf)
        _UniffiConverterBytes.write(value.funding_txid, buf)
        _UniffiConverterUInt32.write(value.funding_output, buf)
        _UniffiConverterBool.write(value.connected, buf)
        _UniffiConverterTypeChannelState.write(value.state, buf)
        _UniffiConverterOptionalString.write(value.short_channel_id, buf)
        _UniffiConverterOptionalBytes.write(value.channel_id, buf)


class FundOutput:
    txid: "bytes"
    output: "int"
    amount_msat: "int"
    status: "OutputStatus"
    address: "typing.Optional[str]"
    blockheight: "typing.Optional[int]"
    def __init__(self, *, txid: "bytes", output: "int", amount_msat: "int", status: "OutputStatus", address: "typing.Optional[str]", blockheight: "typing.Optional[int]"):
        self.txid = txid
        self.output = output
        self.amount_msat = amount_msat
        self.status = status
        self.address = address
        self.blockheight = blockheight

    def __str__(self):
        return "FundOutput(txid={}, output={}, amount_msat={}, status={}, address={}, blockheight={})".format(self.txid, self.output, self.amount_msat, self.status, self.address, self.blockheight)

    def __eq__(self, other):
        if self.txid != other.txid:
            return False
        if self.output != other.output:
            return False
        if self.amount_msat != other.amount_msat:
            return False
        if self.status != other.status:
            return False
        if self.address != other.address:
            return False
        if self.blockheight != other.blockheight:
            return False
        return True

class _UniffiConverterTypeFundOutput(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return FundOutput(
            txid=_UniffiConverterBytes.read(buf),
            output=_UniffiConverterUInt32.read(buf),
            amount_msat=_UniffiConverterUInt64.read(buf),
            status=_UniffiConverterTypeOutputStatus.read(buf),
            address=_UniffiConverterOptionalString.read(buf),
            blockheight=_UniffiConverterOptionalUInt32.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterBytes.check_lower(value.txid)
        _UniffiConverterUInt32.check_lower(value.output)
        _UniffiConverterUInt64.check_lower(value.amount_msat)
        _UniffiConverterTypeOutputStatus.check_lower(value.status)
        _UniffiConverterOptionalString.check_lower(value.address)
        _UniffiConverterOptionalUInt32.check_lower(value.blockheight)

    @staticmethod
    def write(value, buf):
        _UniffiConverterBytes.write(value.txid, buf)
        _UniffiConverterUInt32.write(value.output, buf)
        _UniffiConverterUInt64.write(value.amount_msat, buf)
        _UniffiConverterTypeOutputStatus.write(value.status, buf)
        _UniffiConverterOptionalString.write(value.address, buf)
        _UniffiConverterOptionalUInt32.write(value.blockheight, buf)


class GetInfoResponse:
    id: "bytes"
    alias: "typing.Optional[str]"
    color: "bytes"
    num_peers: "int"
    num_pending_channels: "int"
    num_active_channels: "int"
    num_inactive_channels: "int"
    version: "str"
    lightning_dir: "str"
    blockheight: "int"
    network: "str"
    fees_collected_msat: "int"
    def __init__(self, *, id: "bytes", alias: "typing.Optional[str]", color: "bytes", num_peers: "int", num_pending_channels: "int", num_active_channels: "int", num_inactive_channels: "int", version: "str", lightning_dir: "str", blockheight: "int", network: "str", fees_collected_msat: "int"):
        self.id = id
        self.alias = alias
        self.color = color
        self.num_peers = num_peers
        self.num_pending_channels = num_pending_channels
        self.num_active_channels = num_active_channels
        self.num_inactive_channels = num_inactive_channels
        self.version = version
        self.lightning_dir = lightning_dir
        self.blockheight = blockheight
        self.network = network
        self.fees_collected_msat = fees_collected_msat

    def __str__(self):
        return "GetInfoResponse(id={}, alias={}, color={}, num_peers={}, num_pending_channels={}, num_active_channels={}, num_inactive_channels={}, version={}, lightning_dir={}, blockheight={}, network={}, fees_collected_msat={})".format(self.id, self.alias, self.color, self.num_peers, self.num_pending_channels, self.num_active_channels, self.num_inactive_channels, self.version, self.lightning_dir, self.blockheight, self.network, self.fees_collected_msat)

    def __eq__(self, other):
        if self.id != other.id:
            return False
        if self.alias != other.alias:
            return False
        if self.color != other.color:
            return False
        if self.num_peers != other.num_peers:
            return False
        if self.num_pending_channels != other.num_pending_channels:
            return False
        if self.num_active_channels != other.num_active_channels:
            return False
        if self.num_inactive_channels != other.num_inactive_channels:
            return False
        if self.version != other.version:
            return False
        if self.lightning_dir != other.lightning_dir:
            return False
        if self.blockheight != other.blockheight:
            return False
        if self.network != other.network:
            return False
        if self.fees_collected_msat != other.fees_collected_msat:
            return False
        return True

class _UniffiConverterTypeGetInfoResponse(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return GetInfoResponse(
            id=_UniffiConverterBytes.read(buf),
            alias=_UniffiConverterOptionalString.read(buf),
            color=_UniffiConverterBytes.read(buf),
            num_peers=_UniffiConverterUInt32.read(buf),
            num_pending_channels=_UniffiConverterUInt32.read(buf),
            num_active_channels=_UniffiConverterUInt32.read(buf),
            num_inactive_channels=_UniffiConverterUInt32.read(buf),
            version=_UniffiConverterString.read(buf),
            lightning_dir=_UniffiConverterString.read(buf),
            blockheight=_UniffiConverterUInt32.read(buf),
            network=_UniffiConverterString.read(buf),
            fees_collected_msat=_UniffiConverterUInt64.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterBytes.check_lower(value.id)
        _UniffiConverterOptionalString.check_lower(value.alias)
        _UniffiConverterBytes.check_lower(value.color)
        _UniffiConverterUInt32.check_lower(value.num_peers)
        _UniffiConverterUInt32.check_lower(value.num_pending_channels)
        _UniffiConverterUInt32.check_lower(value.num_active_channels)
        _UniffiConverterUInt32.check_lower(value.num_inactive_channels)
        _UniffiConverterString.check_lower(value.version)
        _UniffiConverterString.check_lower(value.lightning_dir)
        _UniffiConverterUInt32.check_lower(value.blockheight)
        _UniffiConverterString.check_lower(value.network)
        _UniffiConverterUInt64.check_lower(value.fees_collected_msat)

    @staticmethod
    def write(value, buf):
        _UniffiConverterBytes.write(value.id, buf)
        _UniffiConverterOptionalString.write(value.alias, buf)
        _UniffiConverterBytes.write(value.color, buf)
        _UniffiConverterUInt32.write(value.num_peers, buf)
        _UniffiConverterUInt32.write(value.num_pending_channels, buf)
        _UniffiConverterUInt32.write(value.num_active_channels, buf)
        _UniffiConverterUInt32.write(value.num_inactive_channels, buf)
        _UniffiConverterString.write(value.version, buf)
        _UniffiConverterString.write(value.lightning_dir, buf)
        _UniffiConverterUInt32.write(value.blockheight, buf)
        _UniffiConverterString.write(value.network, buf)
        _UniffiConverterUInt64.write(value.fees_collected_msat, buf)


class InvoicePaidEvent:
    """
    Details of a paid invoice.
    """

    payment_hash: "bytes"
    """
    The payment hash of the paid invoice.
    """

    bolt11: "str"
    """
    The bolt11 invoice string.
    """

    preimage: "bytes"
    """
    The preimage that proves payment.
    """

    label: "str"
    """
    The label assigned to the invoice.
    """

    amount_msat: "int"
    """
    Amount received in millisatoshis.
    """

    def __init__(self, *, payment_hash: "bytes", bolt11: "str", preimage: "bytes", label: "str", amount_msat: "int"):
        self.payment_hash = payment_hash
        self.bolt11 = bolt11
        self.preimage = preimage
        self.label = label
        self.amount_msat = amount_msat

    def __str__(self):
        return "InvoicePaidEvent(payment_hash={}, bolt11={}, preimage={}, label={}, amount_msat={})".format(self.payment_hash, self.bolt11, self.preimage, self.label, self.amount_msat)

    def __eq__(self, other):
        if self.payment_hash != other.payment_hash:
            return False
        if self.bolt11 != other.bolt11:
            return False
        if self.preimage != other.preimage:
            return False
        if self.label != other.label:
            return False
        if self.amount_msat != other.amount_msat:
            return False
        return True

class _UniffiConverterTypeInvoicePaidEvent(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return InvoicePaidEvent(
            payment_hash=_UniffiConverterBytes.read(buf),
            bolt11=_UniffiConverterString.read(buf),
            preimage=_UniffiConverterBytes.read(buf),
            label=_UniffiConverterString.read(buf),
            amount_msat=_UniffiConverterUInt64.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterBytes.check_lower(value.payment_hash)
        _UniffiConverterString.check_lower(value.bolt11)
        _UniffiConverterBytes.check_lower(value.preimage)
        _UniffiConverterString.check_lower(value.label)
        _UniffiConverterUInt64.check_lower(value.amount_msat)

    @staticmethod
    def write(value, buf):
        _UniffiConverterBytes.write(value.payment_hash, buf)
        _UniffiConverterString.write(value.bolt11, buf)
        _UniffiConverterBytes.write(value.preimage, buf)
        _UniffiConverterString.write(value.label, buf)
        _UniffiConverterUInt64.write(value.amount_msat, buf)


class ListFundsResponse:
    outputs: "typing.List[FundOutput]"
    channels: "typing.List[FundChannel]"
    def __init__(self, *, outputs: "typing.List[FundOutput]", channels: "typing.List[FundChannel]"):
        self.outputs = outputs
        self.channels = channels

    def __str__(self):
        return "ListFundsResponse(outputs={}, channels={})".format(self.outputs, self.channels)

    def __eq__(self, other):
        if self.outputs != other.outputs:
            return False
        if self.channels != other.channels:
            return False
        return True

class _UniffiConverterTypeListFundsResponse(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return ListFundsResponse(
            outputs=_UniffiConverterSequenceTypeFundOutput.read(buf),
            channels=_UniffiConverterSequenceTypeFundChannel.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterSequenceTypeFundOutput.check_lower(value.outputs)
        _UniffiConverterSequenceTypeFundChannel.check_lower(value.channels)

    @staticmethod
    def write(value, buf):
        _UniffiConverterSequenceTypeFundOutput.write(value.outputs, buf)
        _UniffiConverterSequenceTypeFundChannel.write(value.channels, buf)


class ListPeerChannelsResponse:
    channels: "typing.List[PeerChannel]"
    def __init__(self, *, channels: "typing.List[PeerChannel]"):
        self.channels = channels

    def __str__(self):
        return "ListPeerChannelsResponse(channels={})".format(self.channels)

    def __eq__(self, other):
        if self.channels != other.channels:
            return False
        return True

class _UniffiConverterTypeListPeerChannelsResponse(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return ListPeerChannelsResponse(
            channels=_UniffiConverterSequenceTypePeerChannel.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterSequenceTypePeerChannel.check_lower(value.channels)

    @staticmethod
    def write(value, buf):
        _UniffiConverterSequenceTypePeerChannel.write(value.channels, buf)


class ListPeersResponse:
    peers: "typing.List[Peer]"
    def __init__(self, *, peers: "typing.List[Peer]"):
        self.peers = peers

    def __str__(self):
        return "ListPeersResponse(peers={})".format(self.peers)

    def __eq__(self, other):
        if self.peers != other.peers:
            return False
        return True

class _UniffiConverterTypeListPeersResponse(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return ListPeersResponse(
            peers=_UniffiConverterSequenceTypePeer.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterSequenceTypePeer.check_lower(value.peers)

    @staticmethod
    def write(value, buf):
        _UniffiConverterSequenceTypePeer.write(value.peers, buf)


class OnchainReceiveResponse:
    bech32: "str"
    p2tr: "str"
    def __init__(self, *, bech32: "str", p2tr: "str"):
        self.bech32 = bech32
        self.p2tr = p2tr

    def __str__(self):
        return "OnchainReceiveResponse(bech32={}, p2tr={})".format(self.bech32, self.p2tr)

    def __eq__(self, other):
        if self.bech32 != other.bech32:
            return False
        if self.p2tr != other.p2tr:
            return False
        return True

class _UniffiConverterTypeOnchainReceiveResponse(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return OnchainReceiveResponse(
            bech32=_UniffiConverterString.read(buf),
            p2tr=_UniffiConverterString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.bech32)
        _UniffiConverterString.check_lower(value.p2tr)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.bech32, buf)
        _UniffiConverterString.write(value.p2tr, buf)


class OnchainSendResponse:
    tx: "bytes"
    txid: "bytes"
    psbt: "str"
    def __init__(self, *, tx: "bytes", txid: "bytes", psbt: "str"):
        self.tx = tx
        self.txid = txid
        self.psbt = psbt

    def __str__(self):
        return "OnchainSendResponse(tx={}, txid={}, psbt={})".format(self.tx, self.txid, self.psbt)

    def __eq__(self, other):
        if self.tx != other.tx:
            return False
        if self.txid != other.txid:
            return False
        if self.psbt != other.psbt:
            return False
        return True

class _UniffiConverterTypeOnchainSendResponse(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return OnchainSendResponse(
            tx=_UniffiConverterBytes.read(buf),
            txid=_UniffiConverterBytes.read(buf),
            psbt=_UniffiConverterString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterBytes.check_lower(value.tx)
        _UniffiConverterBytes.check_lower(value.txid)
        _UniffiConverterString.check_lower(value.psbt)

    @staticmethod
    def write(value, buf):
        _UniffiConverterBytes.write(value.tx, buf)
        _UniffiConverterBytes.write(value.txid, buf)
        _UniffiConverterString.write(value.psbt, buf)


class Peer:
    id: "bytes"
    connected: "bool"
    num_channels: "typing.Optional[int]"
    netaddr: "typing.List[str]"
    remote_addr: "typing.Optional[str]"
    features: "typing.Optional[bytes]"
    def __init__(self, *, id: "bytes", connected: "bool", num_channels: "typing.Optional[int]", netaddr: "typing.List[str]", remote_addr: "typing.Optional[str]", features: "typing.Optional[bytes]"):
        self.id = id
        self.connected = connected
        self.num_channels = num_channels
        self.netaddr = netaddr
        self.remote_addr = remote_addr
        self.features = features

    def __str__(self):
        return "Peer(id={}, connected={}, num_channels={}, netaddr={}, remote_addr={}, features={})".format(self.id, self.connected, self.num_channels, self.netaddr, self.remote_addr, self.features)

    def __eq__(self, other):
        if self.id != other.id:
            return False
        if self.connected != other.connected:
            return False
        if self.num_channels != other.num_channels:
            return False
        if self.netaddr != other.netaddr:
            return False
        if self.remote_addr != other.remote_addr:
            return False
        if self.features != other.features:
            return False
        return True

class _UniffiConverterTypePeer(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return Peer(
            id=_UniffiConverterBytes.read(buf),
            connected=_UniffiConverterBool.read(buf),
            num_channels=_UniffiConverterOptionalUInt32.read(buf),
            netaddr=_UniffiConverterSequenceString.read(buf),
            remote_addr=_UniffiConverterOptionalString.read(buf),
            features=_UniffiConverterOptionalBytes.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterBytes.check_lower(value.id)
        _UniffiConverterBool.check_lower(value.connected)
        _UniffiConverterOptionalUInt32.check_lower(value.num_channels)
        _UniffiConverterSequenceString.check_lower(value.netaddr)
        _UniffiConverterOptionalString.check_lower(value.remote_addr)
        _UniffiConverterOptionalBytes.check_lower(value.features)

    @staticmethod
    def write(value, buf):
        _UniffiConverterBytes.write(value.id, buf)
        _UniffiConverterBool.write(value.connected, buf)
        _UniffiConverterOptionalUInt32.write(value.num_channels, buf)
        _UniffiConverterSequenceString.write(value.netaddr, buf)
        _UniffiConverterOptionalString.write(value.remote_addr, buf)
        _UniffiConverterOptionalBytes.write(value.features, buf)


class PeerChannel:
    peer_id: "bytes"
    peer_connected: "bool"
    state: "ChannelState"
    short_channel_id: "typing.Optional[str]"
    channel_id: "typing.Optional[bytes]"
    funding_txid: "typing.Optional[bytes]"
    funding_outnum: "typing.Optional[int]"
    to_us_msat: "typing.Optional[int]"
    total_msat: "typing.Optional[int]"
    spendable_msat: "typing.Optional[int]"
    receivable_msat: "typing.Optional[int]"
    def __init__(self, *, peer_id: "bytes", peer_connected: "bool", state: "ChannelState", short_channel_id: "typing.Optional[str]", channel_id: "typing.Optional[bytes]", funding_txid: "typing.Optional[bytes]", funding_outnum: "typing.Optional[int]", to_us_msat: "typing.Optional[int]", total_msat: "typing.Optional[int]", spendable_msat: "typing.Optional[int]", receivable_msat: "typing.Optional[int]"):
        self.peer_id = peer_id
        self.peer_connected = peer_connected
        self.state = state
        self.short_channel_id = short_channel_id
        self.channel_id = channel_id
        self.funding_txid = funding_txid
        self.funding_outnum = funding_outnum
        self.to_us_msat = to_us_msat
        self.total_msat = total_msat
        self.spendable_msat = spendable_msat
        self.receivable_msat = receivable_msat

    def __str__(self):
        return "PeerChannel(peer_id={}, peer_connected={}, state={}, short_channel_id={}, channel_id={}, funding_txid={}, funding_outnum={}, to_us_msat={}, total_msat={}, spendable_msat={}, receivable_msat={})".format(self.peer_id, self.peer_connected, self.state, self.short_channel_id, self.channel_id, self.funding_txid, self.funding_outnum, self.to_us_msat, self.total_msat, self.spendable_msat, self.receivable_msat)

    def __eq__(self, other):
        if self.peer_id != other.peer_id:
            return False
        if self.peer_connected != other.peer_connected:
            return False
        if self.state != other.state:
            return False
        if self.short_channel_id != other.short_channel_id:
            return False
        if self.channel_id != other.channel_id:
            return False
        if self.funding_txid != other.funding_txid:
            return False
        if self.funding_outnum != other.funding_outnum:
            return False
        if self.to_us_msat != other.to_us_msat:
            return False
        if self.total_msat != other.total_msat:
            return False
        if self.spendable_msat != other.spendable_msat:
            return False
        if self.receivable_msat != other.receivable_msat:
            return False
        return True

class _UniffiConverterTypePeerChannel(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return PeerChannel(
            peer_id=_UniffiConverterBytes.read(buf),
            peer_connected=_UniffiConverterBool.read(buf),
            state=_UniffiConverterTypeChannelState.read(buf),
            short_channel_id=_UniffiConverterOptionalString.read(buf),
            channel_id=_UniffiConverterOptionalBytes.read(buf),
            funding_txid=_UniffiConverterOptionalBytes.read(buf),
            funding_outnum=_UniffiConverterOptionalUInt32.read(buf),
            to_us_msat=_UniffiConverterOptionalUInt64.read(buf),
            total_msat=_UniffiConverterOptionalUInt64.read(buf),
            spendable_msat=_UniffiConverterOptionalUInt64.read(buf),
            receivable_msat=_UniffiConverterOptionalUInt64.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterBytes.check_lower(value.peer_id)
        _UniffiConverterBool.check_lower(value.peer_connected)
        _UniffiConverterTypeChannelState.check_lower(value.state)
        _UniffiConverterOptionalString.check_lower(value.short_channel_id)
        _UniffiConverterOptionalBytes.check_lower(value.channel_id)
        _UniffiConverterOptionalBytes.check_lower(value.funding_txid)
        _UniffiConverterOptionalUInt32.check_lower(value.funding_outnum)
        _UniffiConverterOptionalUInt64.check_lower(value.to_us_msat)
        _UniffiConverterOptionalUInt64.check_lower(value.total_msat)
        _UniffiConverterOptionalUInt64.check_lower(value.spendable_msat)
        _UniffiConverterOptionalUInt64.check_lower(value.receivable_msat)

    @staticmethod
    def write(value, buf):
        _UniffiConverterBytes.write(value.peer_id, buf)
        _UniffiConverterBool.write(value.peer_connected, buf)
        _UniffiConverterTypeChannelState.write(value.state, buf)
        _UniffiConverterOptionalString.write(value.short_channel_id, buf)
        _UniffiConverterOptionalBytes.write(value.channel_id, buf)
        _UniffiConverterOptionalBytes.write(value.funding_txid, buf)
        _UniffiConverterOptionalUInt32.write(value.funding_outnum, buf)
        _UniffiConverterOptionalUInt64.write(value.to_us_msat, buf)
        _UniffiConverterOptionalUInt64.write(value.total_msat, buf)
        _UniffiConverterOptionalUInt64.write(value.spendable_msat, buf)
        _UniffiConverterOptionalUInt64.write(value.receivable_msat, buf)


class ReceiveResponse:
    bolt11: "str"
    def __init__(self, *, bolt11: "str"):
        self.bolt11 = bolt11

    def __str__(self):
        return "ReceiveResponse(bolt11={})".format(self.bolt11)

    def __eq__(self, other):
        if self.bolt11 != other.bolt11:
            return False
        return True

class _UniffiConverterTypeReceiveResponse(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return ReceiveResponse(
            bolt11=_UniffiConverterString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterString.check_lower(value.bolt11)

    @staticmethod
    def write(value, buf):
        _UniffiConverterString.write(value.bolt11, buf)


class SendResponse:
    status: "PayStatus"
    preimage: "bytes"
    amount_msat: "int"
    amount_sent_msat: "int"
    parts: "int"
    def __init__(self, *, status: "PayStatus", preimage: "bytes", amount_msat: "int", amount_sent_msat: "int", parts: "int"):
        self.status = status
        self.preimage = preimage
        self.amount_msat = amount_msat
        self.amount_sent_msat = amount_sent_msat
        self.parts = parts

    def __str__(self):
        return "SendResponse(status={}, preimage={}, amount_msat={}, amount_sent_msat={}, parts={})".format(self.status, self.preimage, self.amount_msat, self.amount_sent_msat, self.parts)

    def __eq__(self, other):
        if self.status != other.status:
            return False
        if self.preimage != other.preimage:
            return False
        if self.amount_msat != other.amount_msat:
            return False
        if self.amount_sent_msat != other.amount_sent_msat:
            return False
        if self.parts != other.parts:
            return False
        return True

class _UniffiConverterTypeSendResponse(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return SendResponse(
            status=_UniffiConverterTypePayStatus.read(buf),
            preimage=_UniffiConverterBytes.read(buf),
            amount_msat=_UniffiConverterUInt64.read(buf),
            amount_sent_msat=_UniffiConverterUInt64.read(buf),
            parts=_UniffiConverterUInt32.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterTypePayStatus.check_lower(value.status)
        _UniffiConverterBytes.check_lower(value.preimage)
        _UniffiConverterUInt64.check_lower(value.amount_msat)
        _UniffiConverterUInt64.check_lower(value.amount_sent_msat)
        _UniffiConverterUInt32.check_lower(value.parts)

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypePayStatus.write(value.status, buf)
        _UniffiConverterBytes.write(value.preimage, buf)
        _UniffiConverterUInt64.write(value.amount_msat, buf)
        _UniffiConverterUInt64.write(value.amount_sent_msat, buf)
        _UniffiConverterUInt32.write(value.parts, buf)





class ChannelState(enum.Enum):
    OPENINGD = 0
    
    CHANNELD_AWAITING_LOCKIN = 1
    
    CHANNELD_NORMAL = 2
    
    CHANNELD_SHUTTING_DOWN = 3
    
    CLOSINGD_SIGEXCHANGE = 4
    
    CLOSINGD_COMPLETE = 5
    
    AWAITING_UNILATERAL = 6
    
    FUNDING_SPEND_SEEN = 7
    
    ONCHAIN = 8
    
    DUALOPEND_OPEN_INIT = 9
    
    DUALOPEND_AWAITING_LOCKIN = 10
    
    DUALOPEND_OPEN_COMMITTED = 11
    
    DUALOPEND_OPEN_COMMIT_READY = 12
    


class _UniffiConverterTypeChannelState(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return ChannelState.OPENINGD
        if variant == 2:
            return ChannelState.CHANNELD_AWAITING_LOCKIN
        if variant == 3:
            return ChannelState.CHANNELD_NORMAL
        if variant == 4:
            return ChannelState.CHANNELD_SHUTTING_DOWN
        if variant == 5:
            return ChannelState.CLOSINGD_SIGEXCHANGE
        if variant == 6:
            return ChannelState.CLOSINGD_COMPLETE
        if variant == 7:
            return ChannelState.AWAITING_UNILATERAL
        if variant == 8:
            return ChannelState.FUNDING_SPEND_SEEN
        if variant == 9:
            return ChannelState.ONCHAIN
        if variant == 10:
            return ChannelState.DUALOPEND_OPEN_INIT
        if variant == 11:
            return ChannelState.DUALOPEND_AWAITING_LOCKIN
        if variant == 12:
            return ChannelState.DUALOPEND_OPEN_COMMITTED
        if variant == 13:
            return ChannelState.DUALOPEND_OPEN_COMMIT_READY
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value == ChannelState.OPENINGD:
            return
        if value == ChannelState.CHANNELD_AWAITING_LOCKIN:
            return
        if value == ChannelState.CHANNELD_NORMAL:
            return
        if value == ChannelState.CHANNELD_SHUTTING_DOWN:
            return
        if value == ChannelState.CLOSINGD_SIGEXCHANGE:
            return
        if value == ChannelState.CLOSINGD_COMPLETE:
            return
        if value == ChannelState.AWAITING_UNILATERAL:
            return
        if value == ChannelState.FUNDING_SPEND_SEEN:
            return
        if value == ChannelState.ONCHAIN:
            return
        if value == ChannelState.DUALOPEND_OPEN_INIT:
            return
        if value == ChannelState.DUALOPEND_AWAITING_LOCKIN:
            return
        if value == ChannelState.DUALOPEND_OPEN_COMMITTED:
            return
        if value == ChannelState.DUALOPEND_OPEN_COMMIT_READY:
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value == ChannelState.OPENINGD:
            buf.write_i32(1)
        if value == ChannelState.CHANNELD_AWAITING_LOCKIN:
            buf.write_i32(2)
        if value == ChannelState.CHANNELD_NORMAL:
            buf.write_i32(3)
        if value == ChannelState.CHANNELD_SHUTTING_DOWN:
            buf.write_i32(4)
        if value == ChannelState.CLOSINGD_SIGEXCHANGE:
            buf.write_i32(5)
        if value == ChannelState.CLOSINGD_COMPLETE:
            buf.write_i32(6)
        if value == ChannelState.AWAITING_UNILATERAL:
            buf.write_i32(7)
        if value == ChannelState.FUNDING_SPEND_SEEN:
            buf.write_i32(8)
        if value == ChannelState.ONCHAIN:
            buf.write_i32(9)
        if value == ChannelState.DUALOPEND_OPEN_INIT:
            buf.write_i32(10)
        if value == ChannelState.DUALOPEND_AWAITING_LOCKIN:
            buf.write_i32(11)
        if value == ChannelState.DUALOPEND_OPEN_COMMITTED:
            buf.write_i32(12)
        if value == ChannelState.DUALOPEND_OPEN_COMMIT_READY:
            buf.write_i32(13)




# Error
# We want to define each variant as a nested class that's also a subclass,
# which is tricky in Python.  To accomplish this we're going to create each
# class separately, then manually add the child classes to the base class's
# __dict__.  All of this happens in dummy class to avoid polluting the module
# namespace.
class Error(Exception):
    pass

_UniffiTempError = Error

class Error:  # type: ignore
    class DuplicateNode(_UniffiTempError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], str):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'str', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "Error.DuplicateNode({})".format(str(self))
    _UniffiTempError.DuplicateNode = DuplicateNode # type: ignore
    class NoSuchNode(_UniffiTempError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], str):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'str', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "Error.NoSuchNode({})".format(str(self))
    _UniffiTempError.NoSuchNode = NoSuchNode # type: ignore
    class UnparseableCreds(_UniffiTempError):
        def __init__(self):
            pass

        def __repr__(self):
            return "Error.UnparseableCreds({})".format(str(self))
    _UniffiTempError.UnparseableCreds = UnparseableCreds # type: ignore
    class PhraseCorrupted(_UniffiTempError):
        def __init__(self):
            pass

        def __repr__(self):
            return "Error.PhraseCorrupted({})".format(str(self))
    _UniffiTempError.PhraseCorrupted = PhraseCorrupted # type: ignore
    class Rpc(_UniffiTempError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], str):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'str', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "Error.Rpc({})".format(str(self))
    _UniffiTempError.Rpc = Rpc # type: ignore
    class Argument(_UniffiTempError):
        def __init__(self, *values):
            if len(values) != 2:
                raise TypeError(f"Expected 2 arguments, found {len(values)}")
            if not isinstance(values[0], str):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'str', got '{type(values[0])}'")
            if not isinstance(values[1], str):
                raise TypeError(f"unexpected type for tuple element 1 - expected 'str', got '{type(values[1])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "Error.Argument({})".format(str(self))
    _UniffiTempError.Argument = Argument # type: ignore
    class Other(_UniffiTempError):
        def __init__(self, *values):
            if len(values) != 1:
                raise TypeError(f"Expected 1 arguments, found {len(values)}")
            if not isinstance(values[0], str):
                raise TypeError(f"unexpected type for tuple element 0 - expected 'str', got '{type(values[0])}'")
            super().__init__(", ".join(map(repr, values)))
            self._values = values

        def __getitem__(self, index):
            return self._values[index]

        def __repr__(self):
            return "Error.Other({})".format(str(self))
    _UniffiTempError.Other = Other # type: ignore

Error = _UniffiTempError # type: ignore
del _UniffiTempError


class _UniffiConverterTypeError(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return Error.DuplicateNode(
                _UniffiConverterString.read(buf),
            )
        if variant == 2:
            return Error.NoSuchNode(
                _UniffiConverterString.read(buf),
            )
        if variant == 3:
            return Error.UnparseableCreds(
            )
        if variant == 4:
            return Error.PhraseCorrupted(
            )
        if variant == 5:
            return Error.Rpc(
                _UniffiConverterString.read(buf),
            )
        if variant == 6:
            return Error.Argument(
                _UniffiConverterString.read(buf),
                _UniffiConverterString.read(buf),
            )
        if variant == 7:
            return Error.Other(
                _UniffiConverterString.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if isinstance(value, Error.DuplicateNode):
            _UniffiConverterString.check_lower(value._values[0])
            return
        if isinstance(value, Error.NoSuchNode):
            _UniffiConverterString.check_lower(value._values[0])
            return
        if isinstance(value, Error.UnparseableCreds):
            return
        if isinstance(value, Error.PhraseCorrupted):
            return
        if isinstance(value, Error.Rpc):
            _UniffiConverterString.check_lower(value._values[0])
            return
        if isinstance(value, Error.Argument):
            _UniffiConverterString.check_lower(value._values[0])
            _UniffiConverterString.check_lower(value._values[1])
            return
        if isinstance(value, Error.Other):
            _UniffiConverterString.check_lower(value._values[0])
            return

    @staticmethod
    def write(value, buf):
        if isinstance(value, Error.DuplicateNode):
            buf.write_i32(1)
            _UniffiConverterString.write(value._values[0], buf)
        if isinstance(value, Error.NoSuchNode):
            buf.write_i32(2)
            _UniffiConverterString.write(value._values[0], buf)
        if isinstance(value, Error.UnparseableCreds):
            buf.write_i32(3)
        if isinstance(value, Error.PhraseCorrupted):
            buf.write_i32(4)
        if isinstance(value, Error.Rpc):
            buf.write_i32(5)
            _UniffiConverterString.write(value._values[0], buf)
        if isinstance(value, Error.Argument):
            buf.write_i32(6)
            _UniffiConverterString.write(value._values[0], buf)
            _UniffiConverterString.write(value._values[1], buf)
        if isinstance(value, Error.Other):
            buf.write_i32(7)
            _UniffiConverterString.write(value._values[0], buf)





class Network(enum.Enum):
    BITCOIN = 0
    
    REGTEST = 1
    


class _UniffiConverterTypeNetwork(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return Network.BITCOIN
        if variant == 2:
            return Network.REGTEST
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value == Network.BITCOIN:
            return
        if value == Network.REGTEST:
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value == Network.BITCOIN:
            buf.write_i32(1)
        if value == Network.REGTEST:
            buf.write_i32(2)







class NodeEvent:
    """
    A real-time event from the node.
    """

    def __init__(self):
        raise RuntimeError("NodeEvent cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class INVOICE_PAID:
        """
        An invoice was paid.
        """

        details: "InvoicePaidEvent"

        def __init__(self,details: "InvoicePaidEvent"):
            self.details = details

        def __str__(self):
            return "NodeEvent.INVOICE_PAID(details={})".format(self.details)

        def __eq__(self, other):
            if not other.is_INVOICE_PAID():
                return False
            if self.details != other.details:
                return False
            return True
    
    class UNKNOWN:
        """
        An unknown event type was received. This can happen if the
        server sends a new event type that this client doesn't know about.
        """


        def __init__(self,):
            pass

        def __str__(self):
            return "NodeEvent.UNKNOWN()".format()

        def __eq__(self, other):
            if not other.is_UNKNOWN():
                return False
            return True
    
    

    # For each variant, we have `is_NAME` and `is_name` methods for easily checking
    # whether an instance is that variant.
    def is_INVOICE_PAID(self) -> bool:
        return isinstance(self, NodeEvent.INVOICE_PAID)
    def is_invoice_paid(self) -> bool:
        return isinstance(self, NodeEvent.INVOICE_PAID)
    def is_UNKNOWN(self) -> bool:
        return isinstance(self, NodeEvent.UNKNOWN)
    def is_unknown(self) -> bool:
        return isinstance(self, NodeEvent.UNKNOWN)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
NodeEvent.INVOICE_PAID = type("NodeEvent.INVOICE_PAID", (NodeEvent.INVOICE_PAID, NodeEvent,), {})  # type: ignore
NodeEvent.UNKNOWN = type("NodeEvent.UNKNOWN", (NodeEvent.UNKNOWN, NodeEvent,), {})  # type: ignore




class _UniffiConverterTypeNodeEvent(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return NodeEvent.INVOICE_PAID(
                _UniffiConverterTypeInvoicePaidEvent.read(buf),
            )
        if variant == 2:
            return NodeEvent.UNKNOWN(
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value.is_INVOICE_PAID():
            _UniffiConverterTypeInvoicePaidEvent.check_lower(value.details)
            return
        if value.is_UNKNOWN():
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value.is_INVOICE_PAID():
            buf.write_i32(1)
            _UniffiConverterTypeInvoicePaidEvent.write(value.details, buf)
        if value.is_UNKNOWN():
            buf.write_i32(2)







class OutputStatus(enum.Enum):
    UNCONFIRMED = 0
    
    CONFIRMED = 1
    
    SPENT = 2
    
    IMMATURE = 3
    


class _UniffiConverterTypeOutputStatus(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return OutputStatus.UNCONFIRMED
        if variant == 2:
            return OutputStatus.CONFIRMED
        if variant == 3:
            return OutputStatus.SPENT
        if variant == 4:
            return OutputStatus.IMMATURE
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value == OutputStatus.UNCONFIRMED:
            return
        if value == OutputStatus.CONFIRMED:
            return
        if value == OutputStatus.SPENT:
            return
        if value == OutputStatus.IMMATURE:
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value == OutputStatus.UNCONFIRMED:
            buf.write_i32(1)
        if value == OutputStatus.CONFIRMED:
            buf.write_i32(2)
        if value == OutputStatus.SPENT:
            buf.write_i32(3)
        if value == OutputStatus.IMMATURE:
            buf.write_i32(4)







class PayStatus(enum.Enum):
    COMPLETE = 0
    
    PENDING = 1
    
    FAILED = 2
    


class _UniffiConverterTypePayStatus(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return PayStatus.COMPLETE
        if variant == 2:
            return PayStatus.PENDING
        if variant == 3:
            return PayStatus.FAILED
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value == PayStatus.COMPLETE:
            return
        if value == PayStatus.PENDING:
            return
        if value == PayStatus.FAILED:
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value == PayStatus.COMPLETE:
            buf.write_i32(1)
        if value == PayStatus.PENDING:
            buf.write_i32(2)
        if value == PayStatus.FAILED:
            buf.write_i32(3)





class _UniffiConverterOptionalUInt32(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterUInt32.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterUInt32.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterUInt32.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalUInt64(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterUInt64.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterUInt64.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterUInt64.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalString(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterString.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterString.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterString.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalBytes(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterBytes.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterBytes.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterBytes.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeNodeEvent(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeNodeEvent.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeNodeEvent.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeNodeEvent.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterSequenceString(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterString.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterString.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterString.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeFundChannel(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeFundChannel.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeFundChannel.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeFundChannel.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeFundOutput(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeFundOutput.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeFundOutput.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeFundOutput.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypePeer(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypePeer.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypePeer.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypePeer.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypePeerChannel(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypePeerChannel.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypePeerChannel.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypePeerChannel.read(buf) for i in range(count)
        ]

# objects.
class CredentialsProtocol(typing.Protocol):
    """
    `Credentials` is a container for `node_id`, the mTLS client
    certificate used to authenticate a client against a node, as well
    as the seed secret if present. If no seed is present in the
    credentials, then the `Client` will not start a signer in the
    background.
    """

    def save(self, ):
        raise NotImplementedError
# Credentials is a Rust-only trait - it's a wrapper around a Rust implementation.
class Credentials():
    """
    `Credentials` is a container for `node_id`, the mTLS client
    certificate used to authenticate a client against a node, as well
    as the seed secret if present. If no seed is present in the
    credentials, then the `Client` will not start a signer in the
    background.
    """

    _pointer: ctypes.c_void_p
    
    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_glsdk_fn_free_credentials, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_glsdk_fn_clone_credentials, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst
    @classmethod
    def load(cls, raw: "bytes"):
        _UniffiConverterBytes.check_lower(raw)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call_with_error(_UniffiConverterTypeError,_UniffiLib.uniffi_glsdk_fn_constructor_credentials_load,
        _UniffiConverterBytes.lower(raw))
        return cls._make_instance_(pointer)



    def save(self, ) -> "bytes":
        return _UniffiConverterBytes.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeError,_UniffiLib.uniffi_glsdk_fn_method_credentials_save,self._uniffi_clone_pointer(),)
        )






class _UniffiConverterTypeCredentials:

    @staticmethod
    def lift(value: int):
        return Credentials._make_instance_(value)

    @staticmethod
    def check_lower(value: Credentials):
        if not isinstance(value, Credentials):
            raise TypeError("Expected Credentials instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: CredentialsProtocol):
        if not isinstance(value, Credentials):
            raise TypeError("Expected Credentials instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: CredentialsProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))
class HandleProtocol(typing.Protocol):
    """
    A handle to interact with a signer loop running and processing
    requests in the background. Used primarily to stop the loop and
    exiting the signer.
    """

    def stop(self, ):
        raise NotImplementedError
# Handle is a Rust-only trait - it's a wrapper around a Rust implementation.
class Handle():
    """
    A handle to interact with a signer loop running and processing
    requests in the background. Used primarily to stop the loop and
    exiting the signer.
    """

    _pointer: ctypes.c_void_p
    
    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_glsdk_fn_free_handle, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_glsdk_fn_clone_handle, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def stop(self, ) -> None:
        _uniffi_rust_call(_UniffiLib.uniffi_glsdk_fn_method_handle_stop,self._uniffi_clone_pointer(),)







class _UniffiConverterTypeHandle:

    @staticmethod
    def lift(value: int):
        return Handle._make_instance_(value)

    @staticmethod
    def check_lower(value: Handle):
        if not isinstance(value, Handle):
            raise TypeError("Expected Handle instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: HandleProtocol):
        if not isinstance(value, Handle):
            raise TypeError("Expected Handle instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: HandleProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))
class NodeProtocol(typing.Protocol):
    """
    The `Node` is an RPC stub representing the node running in the
    cloud. It is the main entrypoint to interact with the node.
    """

    def get_info(self, ):
        """
        Get information about the node.

        Returns basic information about the node including its ID,
        alias, network, and channel counts.
        """

        raise NotImplementedError
    def list_funds(self, ):
        """
        List all funds available to the node.

        Returns information about on-chain outputs and channel funds
        that are available or pending.
        """

        raise NotImplementedError
    def list_peer_channels(self, ):
        """
        List all channels with peers.

        Returns detailed information about all channels including their
        state, capacity, and balances.
        """

        raise NotImplementedError
    def list_peers(self, ):
        """
        List all peers connected to this node.

        Returns information about all peers including their connection
        status.
        """

        raise NotImplementedError
    def onchain_receive(self, ):
        raise NotImplementedError
    def onchain_send(self, destination: "str",amount_or_all: "str"):
        raise NotImplementedError
    def receive(self, label: "str",description: "str",amount_msat: "typing.Optional[int]"):
        """
        Receive an off-chain payment.

        This method generates a request for a payment, also called an
        invoice, that encodes all the information, including amount
        and destination, for a prospective sender to send a lightning
        payment. The invoice includes negotiation of an LSPS2 / JIT
        channel, meaning that if there is no channel sufficient to
        receive the requested funds, the node will negotiate an
        opening, and when/if executed the payment will cause a channel
        to be created, and the incoming payment to be forwarded.
        """

        raise NotImplementedError
    def send(self, invoice: "str",amount_msat: "typing.Optional[int]"):
        raise NotImplementedError
    def stop(self, ):
        """
        Stop the node if it is currently running.
        """

        raise NotImplementedError
    def stream_node_events(self, ):
        """
        Stream real-time events from the node.

        Returns a `NodeEventStream` iterator. Call `next()` repeatedly
        to receive events as they occur (e.g., invoice payments).

        The `next()` method blocks the calling thread until an event
        is available, but does not block the underlying async runtime,
        so other node methods can be called concurrently from other
        threads.
        """

        raise NotImplementedError
# Node is a Rust-only trait - it's a wrapper around a Rust implementation.
class Node():
    """
    The `Node` is an RPC stub representing the node running in the
    cloud. It is the main entrypoint to interact with the node.
    """

    _pointer: ctypes.c_void_p
    def __init__(self, credentials: "Credentials"):
        _UniffiConverterTypeCredentials.check_lower(credentials)
        
        self._pointer = _uniffi_rust_call_with_error(_UniffiConverterTypeError,_UniffiLib.uniffi_glsdk_fn_constructor_node_new,
        _UniffiConverterTypeCredentials.lower(credentials))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_glsdk_fn_free_node, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_glsdk_fn_clone_node, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def get_info(self, ) -> "GetInfoResponse":
        """
        Get information about the node.

        Returns basic information about the node including its ID,
        alias, network, and channel counts.
        """

        return _UniffiConverterTypeGetInfoResponse.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeError,_UniffiLib.uniffi_glsdk_fn_method_node_get_info,self._uniffi_clone_pointer(),)
        )





    def list_funds(self, ) -> "ListFundsResponse":
        """
        List all funds available to the node.

        Returns information about on-chain outputs and channel funds
        that are available or pending.
        """

        return _UniffiConverterTypeListFundsResponse.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeError,_UniffiLib.uniffi_glsdk_fn_method_node_list_funds,self._uniffi_clone_pointer(),)
        )





    def list_peer_channels(self, ) -> "ListPeerChannelsResponse":
        """
        List all channels with peers.

        Returns detailed information about all channels including their
        state, capacity, and balances.
        """

        return _UniffiConverterTypeListPeerChannelsResponse.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeError,_UniffiLib.uniffi_glsdk_fn_method_node_list_peer_channels,self._uniffi_clone_pointer(),)
        )





    def list_peers(self, ) -> "ListPeersResponse":
        """
        List all peers connected to this node.

        Returns information about all peers including their connection
        status.
        """

        return _UniffiConverterTypeListPeersResponse.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeError,_UniffiLib.uniffi_glsdk_fn_method_node_list_peers,self._uniffi_clone_pointer(),)
        )





    def onchain_receive(self, ) -> "OnchainReceiveResponse":
        return _UniffiConverterTypeOnchainReceiveResponse.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeError,_UniffiLib.uniffi_glsdk_fn_method_node_onchain_receive,self._uniffi_clone_pointer(),)
        )





    def onchain_send(self, destination: "str",amount_or_all: "str") -> "OnchainSendResponse":
        _UniffiConverterString.check_lower(destination)
        
        _UniffiConverterString.check_lower(amount_or_all)
        
        return _UniffiConverterTypeOnchainSendResponse.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeError,_UniffiLib.uniffi_glsdk_fn_method_node_onchain_send,self._uniffi_clone_pointer(),
        _UniffiConverterString.lower(destination),
        _UniffiConverterString.lower(amount_or_all))
        )





    def receive(self, label: "str",description: "str",amount_msat: "typing.Optional[int]") -> "ReceiveResponse":
        """
        Receive an off-chain payment.

        This method generates a request for a payment, also called an
        invoice, that encodes all the information, including amount
        and destination, for a prospective sender to send a lightning
        payment. The invoice includes negotiation of an LSPS2 / JIT
        channel, meaning that if there is no channel sufficient to
        receive the requested funds, the node will negotiate an
        opening, and when/if executed the payment will cause a channel
        to be created, and the incoming payment to be forwarded.
        """

        _UniffiConverterString.check_lower(label)
        
        _UniffiConverterString.check_lower(description)
        
        _UniffiConverterOptionalUInt64.check_lower(amount_msat)
        
        return _UniffiConverterTypeReceiveResponse.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeError,_UniffiLib.uniffi_glsdk_fn_method_node_receive,self._uniffi_clone_pointer(),
        _UniffiConverterString.lower(label),
        _UniffiConverterString.lower(description),
        _UniffiConverterOptionalUInt64.lower(amount_msat))
        )





    def send(self, invoice: "str",amount_msat: "typing.Optional[int]") -> "SendResponse":
        _UniffiConverterString.check_lower(invoice)
        
        _UniffiConverterOptionalUInt64.check_lower(amount_msat)
        
        return _UniffiConverterTypeSendResponse.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeError,_UniffiLib.uniffi_glsdk_fn_method_node_send,self._uniffi_clone_pointer(),
        _UniffiConverterString.lower(invoice),
        _UniffiConverterOptionalUInt64.lower(amount_msat))
        )





    def stop(self, ) -> None:
        """
        Stop the node if it is currently running.
        """

        _uniffi_rust_call_with_error(_UniffiConverterTypeError,_UniffiLib.uniffi_glsdk_fn_method_node_stop,self._uniffi_clone_pointer(),)






    def stream_node_events(self, ) -> "NodeEventStream":
        """
        Stream real-time events from the node.

        Returns a `NodeEventStream` iterator. Call `next()` repeatedly
        to receive events as they occur (e.g., invoice payments).

        The `next()` method blocks the calling thread until an event
        is available, but does not block the underlying async runtime,
        so other node methods can be called concurrently from other
        threads.
        """

        return _UniffiConverterTypeNodeEventStream.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeError,_UniffiLib.uniffi_glsdk_fn_method_node_stream_node_events,self._uniffi_clone_pointer(),)
        )






class _UniffiConverterTypeNode:

    @staticmethod
    def lift(value: int):
        return Node._make_instance_(value)

    @staticmethod
    def check_lower(value: Node):
        if not isinstance(value, Node):
            raise TypeError("Expected Node instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: NodeProtocol):
        if not isinstance(value, Node):
            raise TypeError("Expected Node instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: NodeProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))
class NodeEventStreamProtocol(typing.Protocol):
    """
    A stream of node events. Call `next()` to receive the next event.

    The stream is backed by a gRPC streaming connection to the node.
    Each call to `next()` blocks the calling thread until an event is
    available, but does not block the tokio runtime - other node
    operations can proceed concurrently from other threads.
    """

    def next(self, ):
        """
        Get the next event from the stream.

        Blocks the calling thread until an event is available or the
        stream ends. Returns `None` when the stream is exhausted or
        the connection is lost.
        """

        raise NotImplementedError
# NodeEventStream is a Rust-only trait - it's a wrapper around a Rust implementation.
class NodeEventStream():
    """
    A stream of node events. Call `next()` to receive the next event.

    The stream is backed by a gRPC streaming connection to the node.
    Each call to `next()` blocks the calling thread until an event is
    available, but does not block the tokio runtime - other node
    operations can proceed concurrently from other threads.
    """

    _pointer: ctypes.c_void_p
    
    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_glsdk_fn_free_nodeeventstream, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_glsdk_fn_clone_nodeeventstream, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def next(self, ) -> "typing.Optional[NodeEvent]":
        """
        Get the next event from the stream.

        Blocks the calling thread until an event is available or the
        stream ends. Returns `None` when the stream is exhausted or
        the connection is lost.
        """

        return _UniffiConverterOptionalTypeNodeEvent.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeError,_UniffiLib.uniffi_glsdk_fn_method_nodeeventstream_next,self._uniffi_clone_pointer(),)
        )






class _UniffiConverterTypeNodeEventStream:

    @staticmethod
    def lift(value: int):
        return NodeEventStream._make_instance_(value)

    @staticmethod
    def check_lower(value: NodeEventStream):
        if not isinstance(value, NodeEventStream):
            raise TypeError("Expected NodeEventStream instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: NodeEventStreamProtocol):
        if not isinstance(value, NodeEventStream):
            raise TypeError("Expected NodeEventStream instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: NodeEventStreamProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))
class SchedulerProtocol(typing.Protocol):
    def recover(self, signer: "Signer"):
        raise NotImplementedError
    def register(self, signer: "Signer",code: "typing.Optional[str]"):
        raise NotImplementedError
# Scheduler is a Rust-only trait - it's a wrapper around a Rust implementation.
class Scheduler():
    _pointer: ctypes.c_void_p
    def __init__(self, network: "Network"):
        """
        Create a `Scheduler` instance configured with the Greenlight
        production service pre-configured.
        """

        _UniffiConverterTypeNetwork.check_lower(network)
        
        self._pointer = _uniffi_rust_call_with_error(_UniffiConverterTypeError,_UniffiLib.uniffi_glsdk_fn_constructor_scheduler_new,
        _UniffiConverterTypeNetwork.lower(network))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_glsdk_fn_free_scheduler, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_glsdk_fn_clone_scheduler, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def recover(self, signer: "Signer") -> "Credentials":
        _UniffiConverterTypeSigner.check_lower(signer)
        
        return _UniffiConverterTypeCredentials.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeError,_UniffiLib.uniffi_glsdk_fn_method_scheduler_recover,self._uniffi_clone_pointer(),
        _UniffiConverterTypeSigner.lower(signer))
        )





    def register(self, signer: "Signer",code: "typing.Optional[str]") -> "Credentials":
        _UniffiConverterTypeSigner.check_lower(signer)
        
        _UniffiConverterOptionalString.check_lower(code)
        
        return _UniffiConverterTypeCredentials.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeError,_UniffiLib.uniffi_glsdk_fn_method_scheduler_register,self._uniffi_clone_pointer(),
        _UniffiConverterTypeSigner.lower(signer),
        _UniffiConverterOptionalString.lower(code))
        )






class _UniffiConverterTypeScheduler:

    @staticmethod
    def lift(value: int):
        return Scheduler._make_instance_(value)

    @staticmethod
    def check_lower(value: Scheduler):
        if not isinstance(value, Scheduler):
            raise TypeError("Expected Scheduler instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: SchedulerProtocol):
        if not isinstance(value, Scheduler):
            raise TypeError("Expected Scheduler instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: SchedulerProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))
class SignerProtocol(typing.Protocol):
    def authenticate(self, creds: "Credentials"):
        raise NotImplementedError
    def node_id(self, ):
        raise NotImplementedError
    def start(self, ):
        raise NotImplementedError
# Signer is a Rust-only trait - it's a wrapper around a Rust implementation.
class Signer():
    _pointer: ctypes.c_void_p
    def __init__(self, phrase: "str"):
        _UniffiConverterString.check_lower(phrase)
        
        self._pointer = _uniffi_rust_call_with_error(_UniffiConverterTypeError,_UniffiLib.uniffi_glsdk_fn_constructor_signer_new,
        _UniffiConverterString.lower(phrase))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_glsdk_fn_free_signer, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_glsdk_fn_clone_signer, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def authenticate(self, creds: "Credentials") -> "Signer":
        _UniffiConverterTypeCredentials.check_lower(creds)
        
        return _UniffiConverterTypeSigner.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeError,_UniffiLib.uniffi_glsdk_fn_method_signer_authenticate,self._uniffi_clone_pointer(),
        _UniffiConverterTypeCredentials.lower(creds))
        )





    def node_id(self, ) -> "bytes":
        return _UniffiConverterBytes.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_glsdk_fn_method_signer_node_id,self._uniffi_clone_pointer(),)
        )





    def start(self, ) -> "Handle":
        return _UniffiConverterTypeHandle.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeError,_UniffiLib.uniffi_glsdk_fn_method_signer_start,self._uniffi_clone_pointer(),)
        )






class _UniffiConverterTypeSigner:

    @staticmethod
    def lift(value: int):
        return Signer._make_instance_(value)

    @staticmethod
    def check_lower(value: Signer):
        if not isinstance(value, Signer):
            raise TypeError("Expected Signer instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: SignerProtocol):
        if not isinstance(value, Signer):
            raise TypeError("Expected Signer instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: SignerProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))

# Async support

__all__ = [
    "InternalError",
    "ChannelState",
    "Error",
    "Network",
    "NodeEvent",
    "OutputStatus",
    "PayStatus",
    "FundChannel",
    "FundOutput",
    "GetInfoResponse",
    "InvoicePaidEvent",
    "ListFundsResponse",
    "ListPeerChannelsResponse",
    "ListPeersResponse",
    "OnchainReceiveResponse",
    "OnchainSendResponse",
    "Peer",
    "PeerChannel",
    "ReceiveResponse",
    "SendResponse",
    "Credentials",
    "Handle",
    "Node",
    "NodeEventStream",
    "Scheduler",
    "Signer",
]

